<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>hadoop_common_fs_source_analyse</title>
<link rel="stylesheet" href="https://stackedit.io/res-min/themes/base.css" />
<script type="text/javascript" src="https://stackedit.io/libs/MathJax/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body><div class="container"><h1 id="目录">目录</h1>

<p><a href="#1-修订记录">1 修订记录</a></p>

<p><a href="#2-摘要">2 摘要</a></p>

<p><a href="#3-orgapachehadoopfs包总述">3 org.apache.hadoop.fs包总述</a></p>

<p><a href="#4-hadoop文件系统概述">4 Hadoop文件系统概述</a></p>

<p><a href="#5-filesystem深入分析">5 FileSystem深入分析</a></p>

<p><a href="#6-输入输出流分析">6 输入输出流分析</a></p>

<p><a href="#7-abstractfilesystem分析">7 AbstractFileSystem分析</a></p>

<p><a href="#8-结论与进一步的工作">8 结论与进一步的工作</a></p>

<h2 id="1-修订记录">1 修订记录</h2>

<table>
<thead>
<tr>
  <th>序号</th>
  <th>时间</th>
  <th>修订人</th>
  <th>版本</th>
</tr>
</thead>
<tbody><tr>
  <td>1</td>
  <td>2011 年 1 月 12 日</td>
  <td>何芳、范永刚</td>
  <td>1.0</td>
</tr>
<tr>
  <td>2</td>
  <td>2011 年 1 月 28 日</td>
  <td>鲍亮</td>
  <td>1.1</td>
</tr>
<tr>
  <td>3</td>
  <td>2014 年 5 月 18 日</td>
  <td>213小组</td>
  <td>1.2</td>
</tr>
</tbody></table>


<p><em>Hadoop版本: 2.4.0</em></p>

<h2 id="2-摘要">2 摘要</h2>

<p>Hadoop是一个用于在通用硬件集群上进行大数据存储和处理的开源软件框架．</p>

<p>它主要包括以下几个模块：</p>

<ul>
<li>Hadoop Common. 包含其它模块需要的库和一些实用程序</li>
<li>Hadoop Distributed File System (HDFS). 一个把数据存储在通用硬件的分布 <br>
式文件系统．在集群内能提供非常高的总计带宽</li>
<li>Hadoop YARN. 用于管理集群内的计算资源和调度用户应用程序的资源管理平台</li>
<li>Hadoop MapReduce. 一个用于大数据处理的编程模型．</li>
</ul>

<p>所有的模块都在设计层面上考虑到了硬件错误．因此这些错误自动的在软件框架内被处理．</p>

<h2 id="3-orgapachehadoopfs包总述">3 org.apache.hadoop.fs包总述</h2>

<p>org.apache.hadoop.fs包提供了一个抽象文件系统的 API．该包下有80多个类和接口，有7个包． <br>
如图3-1所示 <br>
<img src="./images/3-1.jpg" alt="img" title=""></p>

<p>其中有8个接口, 有四个抽象类: FileSystem, AbstractFileSystem, ChecksumFileSystem, TrashPolicy．</p>

<p>FileSystem 抽象类和 AbstractFileSystem 抽象类作为抽象文件系统 <br>
的基类,提供了基本的抽象操作。其中 FileSystem 类是 0.21 版本之前唯一的基类,但在 0.21 版本 <br>
中,出现了 AbstractFileSystem,该类似乎来取代 FileSystem 类原来的部分功能。在这两个基类的 <br>
基础上形成了两个类继承的层次结构。</p>

<p>org.apache.hadoop.fs 子包 ftp、 local、 s3、 s3native 和 Hdfs 类都是实现的对具体的文件系统操作的类. <br>
permission文件夹实现了有关文件访问许可的功能。shell 文件夹实现了对 shell 命令的调用。</p>

<h2 id="4-hadoop文件系统概述">4 Hadoop文件系统概述</h2>

<ul>
<li><a href="#41-类层次结构">4.1 类层次结构</a></li>
<li><a href="#42-输入输出流">4.2 输入输出流</a> <br>
<ul><li><a href="#421-java中的io">4.2.1 Java中的IO</a></li>
<li><a href="#422-hadoop中的io">4.2.2 Hadoop中的IO</a></li></ul></li>
</ul>

<h3 id="41-类层次结构">4.1 类层次结构</h3>

<p>Hadoop 文件系统可以访问多个不同的具体的文件系统,如 HDFS、LocalFS和 S3 文件系统。不 <br>
同的文件系统具有不同的具体实现,Hadoop fs包下实现的是一层类似 Linux 中的 VFS 虚拟文件系统,它从不同 <br>
的文件系统中抽取了共同的操作,这些操作是一般的文件系统都具有的操作,如打开文件,创建 <br>
文件,删除文件,复制文件,获取文件的信息等。这些共同的基本操作组合在一起就形成了 <br>
FileSystem 抽象类和 AbstractFileSystem 抽象类。然后从基类派生,以实现对不同文件系统的统一操作。</p>

<p><em>注解:</em> <br>
HDFS是Hadoop下的另一子模块，它是一个分布式文件系统，是具体的文件系统实现．它和S3, LocalFS都是文件系统. <br>
而org.apache.hadoop.fs包是对不同文件系统的抽象表示，它建立了一个抽象的统一的文件系统接口. <br>
应用程序开发者通过fs包可以和不同的文件系统交互，而不用知道它所进行的操作所在的具体是什么文件系统． <br>
而不同的文件系统开发者则可以根据fs包很容易的使其它文件系统支持Hadoop.</p>

<p>fs包下的类继承层次结构如图 4-1 所示: <br>
<img src="./images/4-1.png" alt="img" title=""> <br>
fs各子包下的类继承层次结构如图4-2所示: <br>
<img src="./images/4-2.png" alt="img" title=""></p>

<p>除 FilterFileSystem 外,FileSystem 的直接子类都是跟具体文件系统交互的类。包括以下子类:</p>

<ul>
<li>由FileSystem派生: <br>
<ul><li>S3FileSystem(org.apache.hadoop.fs.s3) - 数据以块形式存储在<a href="http://aws.amazon.com/s3">Amazon S3</a></li>
<li>NativeS3FileSystem(org.apache.hadoop.fs.s3) - 文件以原生格式存储在<a href="http://aws.amazon.com/s3">Amazon S3</a></li>
<li>ChRootedFileSystem(org.apache.hadoop.fs.viewfs) - 根目录为已有文件系统的某个路径的文件系统</li>
<li>ViewFileSystem(org.apache.hadoop.fs.viewfs) - 实现了客户端的挂载表</li>
<li>DistributedFileSystem(org.apache.hadoop.hdfs) - 为DFS system 实现了抽象类FileSystem. 用户代码通过该类和Hadoop DistributedFileSystem交互</li>
<li>LocalFileSystem - 为还有校验功能的本地文件系统实现了FileSystem API(内部使用RawLocalFileSystem, Decorator Pattern)</li>
<li>RawLocalFileSystem - 为原生本地文件系统实现了FileSystem API</li>
<li>FTPFileSystem(org.apache.hadoop.fs.ftp) - 基于FTP协议和FTP服务器交互的FileSystem API实现</li></ul></li>
<li>由AbstractFileSystem派生: <br>
<ul><li>RawLocalFs(org.apache.hadoop.fs.local) - 内部委派给RawLocalFileSystem来实现AbstractFileSystem API(delegation pattern)</li>
<li>FtpFs(org.apache.hadoop.fs.ftp) - 内部委派给FTPFileSystem来实现AbstractFileSystem API(delegation pattern)</li>
<li>LocalFs(org.apache.hadoop.fs.local) - 和LocalFileSystem的实现类似, 继承ChecksumFs. (内部使用RawLocalFs实现, Decorator Pattern)</li>
<li>ViewFs(org.apache.hadoop.fs.viewfs) - 完全在客户端的内存中实现挂载表</li>
<li>Hdfs - 为Hadoop DistributedFileSystem实现了AbstractFileSystem API</li></ul></li>
</ul>

<p><em>注解:</em></p>

<ul>
<li>LocalFileSystem是加上Checksum功能的本地文件系统，该类和操作系统本地文件系统交互，内部使用RawLocalFileSystem. <br>
RawLocalFileSystem是代表没有Checksum功能的操作系统本地文件系统．</li>
<li>继承自AbstractFileSystem的LocalFS和RawLocalFs结构同上．其内部实现被委派给RawLocalFileSystem.</li>
<li>Amazon S3没有5G限制</li>
</ul>

<p>Hadoop 的使用者可以分为两类,应用程序编写者和文件系统实现者。在 Hadoop 0.21 版本之 <br>
前, FileSystem 类作为一般(抽象)文件系统的基类,一方面为应用程序编写者提供了使用 Hadoop <br>
文件系统的接口,另一方面,为文件系统实现者提供了实现一个文件系统的接口(如 hdfs,本地 <br>
文件系统,FtpFs等等)。</p>

<p>但在 Hadoop 0.21 版本中,出现了 FileContext 类和 AbstractFileSystem 类, <br>
通过这两个 API,可以将原来集中于 FileSystem 一个类中的功能分开,让使用者更加方便的在应 <br>
用程序中使用多个文件系统。</p>

<p>FileContext 这个 API 还没有在 hadoop 中被大量的使用,因为还没有 <br>
被合并到 mapreduce 计算中,但是它包含了正常的 FileSystem 接口没有的新功能,如支持 hdfs <br>
层面的软链接等。</p>

<p>FileContext 类是用来取代 FileSystem 类,向 应用程序编写者 提供使用 Hadoop <br>
文件系统的接口,而原来的 FileSystem 则仅由 文件系统实现者 使用。估计 AbstractFileSystem 类将 <br>
来会取代 FileSystem 类。</p>

<p>从图 4-1, 4-2 中可以看出 AbstractFileSystem 对应 FileSystem,FilterFs 对应 FiterFileSystem, <br>
ChecksumFs 对应 ChecksumFileSystem,LocalFs 对应 LocalFileSystem, RawLocalFs 对应 RawLocalFileSystem。</p>

<p>而在各个具体的文件系统类, FtpFs 和RawLocalFs <br>
通过DelegateToFileSystem(delegation pattern)委派给已有的FTPFileSystem, RawLocalFileSystem, <br>
ViewFs, hdfs的实现是根据各个文件系统的特点直接实现的</p>

<h3 id="42-输入输出流">4.2 输入输出流</h3>

<p>Hadoop 中类的设计在很多地方模仿了 Java。典型的就是文件的输入输出流。 <br>
如图4-3: <br>
<img src="./images/4-3.png" alt="img" title=""> <br>
如图4-4 <br>
<img src="./images/4-4.png" alt="img" title=""></p>

<h4 id="421-java中的io">4.2.1 Java中的IO</h4>

<p>可将 Java 库的 IO 类分割为输入与输出两个部分,这一点在用 Web 浏览器阅读联机 Java 类 <br>
文档时便可知道。通过继承,从 InputStream(输入流)衍生的所有类都拥有名为 read()的基本方 <br>
法,用于读取单个字节或者字节数组。类似地,从 OutputStream 衍生的所有类都拥有基本方法 <br>
write(),用于写入单个字节或者字节数组。然而,我们通常不会用到这些方法;它们之所以存在, <br>
是因为更复杂的类可以利用它们,以便提供一个更有用的接口。因此,我们很少用单个类创建自 <br>
己的系统对象。一般情况下,我们都是将多个对象重叠在一起,提供自己期望的功能。我们之所 <br>
以感到 Java 的流库(Stream Library)异常复杂,正是由于为了创建单独一个结果流,却需要创建 <br>
多个对象的缘故。很有必要按照功能对类进行分类。库的设计者首先决定与输入有关的所有类都 <br>
从 InputStream 继承,而与输出有关的所有类都从 OutputStream 继承。</p>

<h5 id="4211-inputstream">4.2.1.1 InputStream</h5>

<p>InputStream 的作用是标志那些从不同起源地产生输入的类。这些起源地包括(每个都有一个 <br>
相关的 InputStream 子类):</p>

<ol>
<li>字节数组</li>
<li>String 对象</li>
<li>文件</li>
<li>“管道”,它的工作原理与现实生活中的管道类似:将一些东西置入一端,它们在另一端 <br>
出来</li>
<li>一系列其他流,以便我们将其统一收集到单独一个流内</li>
<li>其他起源地,如 Internet 连接等</li>
</ol>

<p>除此以外,FilterInputStream 也属于 InputStream 的一种类型,用它可为“装饰器”类提供一 <br>
个基础类(装饰器模式), 以便将属性或者有用的接口同输入流连接到一起</p>

<p>ByteArrayInputStream:允许内存中的一个缓冲区作为 InputStream,使用从中提取字节的缓冲 <br>
区作为一个数据源使用。通过将其同一个 FilterInputStream 对象连接,可提供一个有用的接口。</p>

<p>StringBufferInputStream:将一个 String 转换成 InputStream 一个 String(字串)。基础的实施 <br>
方案实际采用一个 StringBuffer (字串缓冲)作为一个数据源使用。通过将其同一个 FilterInputStream <br>
对象连接,可提供一个有用的接口。</p>

<p>FileInputStream:用于从文件读取信息代表文件名的一个 String,或者一个 File FileDescriptor <br>
对象作为一个数据源使用。通过将其同一个 FilterInputStream 对象连接,可提供一个有用的接口。</p>

<p>PipedInputStream:读出与之相关的PipedOutputStream 写的数据。实现了“管道化”的概念。</p>

<p>SequenceInputStream:将两个或更多的 InputStream 对象转换成单个 InputStream. 参数为两个 <br>
InputStream 对象或者一个 包含InputStream的Enumeration容器. <br>
作为一个数据源使用, 通过将其同一个 FilterInputStream 对象连接,可提供一个有用的接口.</p>

<p>FilterInputStream:作为具体装饰器类的抽象类; 装饰器类为其他 InputStream 类提供了有用的功能。</p>

<h5 id="4212-outputstream">4.2.1.2 OutputStream</h5>

<p>这一类别包括的类决定了我们的输入往何处去:一个字节数组(但没有 String;假定我们可用 <br>
字节数组创建一个);一个文件;或者一个“管道”。</p>

<p>除此以外,FilterOutputStream 为装饰器类提供了一个基础类,它将属性或者有用的接口 <br>
同输出流连接起来</p>

<p>ByteArrayOutputStream:在内存中创建一个缓冲区。我们发送给流的所有数据都会置入这个 <br>
缓冲区。可选缓冲区的初始大小用于指出数据的目的地。若将其同 FilterOutputStream 对象连接到 <br>
一起,可提供一个有用的接口。</p>

<p>FileOutputStream:将信息发给一个文件,用一个 String 代表文件名,或选用一个 File 或 <br>
FileDescriptor 对象用于指出数据的目的地。若将其同 FilterOutputStream 对象连接到一起,可提供 <br>
一个有用的接口。</p>

<p>PipedOutputStream:我们写给它的任何信息都会自动会从相关的 PipedInputStream 读出。实 <br>
现 了 “ 管 道 化 ” 的 概 念 。 PipedInputStream为多线程处理指出自己数据的目的地, 将其同 <br>
FilterOutputStream 对象连接到一起,便可提供一个有用的接口</p>

<p>FilterOutputStream 对作为装饰器接口使用的类进行抽象处理;那个装饰器为其它OutputStream <br>
类提供了有用的功能</p>

<h5 id="4213-datainputstream">4.2.1.3 DataInputStream</h5>

<p>DataInputStream 从 FilterInputStream 派生, 需要传入一个InputStream. <br>
数据输入流允许应用程序以与机器无关方式从底层输入流中读取基本 Java 数据类型。应用程 <br>
序可以使用数据输出流写入稍后由数据输入流读取的数据。DataInputStream 对于多线程访问不一 <br>
定是安全的。线程安全是可选的,它由此类方法的使用者负责。</p>

<h5 id="4214-dataoutputstream">4.2.1.4 DataOutputStream</h5>

<p>DataOutputStream 数据输出流允许应用程序以适当方式将基本 Java 数据类型写入输出流中。 <br>
然后,应用程序可以使用数据输入流将数据读入。</p>

<h4 id="422-hadoop中的io">4.2.2 Hadoop中的IO</h4>

<p>在 Hadoop 中, FSInputStream(Abstract Class)、 <br>
FSDataInputStream 和 FSDataOutputStream 的作用与 InputStream、 <br>
DataInputStream 和 DataOutputStream 在 Java IO 中的作用类似。用 FileSystem 的 create 方法创建 <br>
一个输出流时的返回值类型为 FSDataOutputStream,而 open 方法则返回一个 FSDataInputStream 实例。</p>

<p>Hadoop 中并没有 FSOutputStream,有些FileSystem类从 OutputStream 派生实现了自己的OutputStream. <br>
很多文件系统都会从 FSInputStream 派生出和自己特定文件系统相关的FSInputStream. <br>
通过这种方式实现自己特定的输入输出流. 如 S3InputStream RawLocalFileSystem 等等。</p>

<h2 id="5-filesystem深入分析">5 FileSystem深入分析</h2>

<ul>
<li><a href="#51-fs中的接口">5.1 fs中的接口</a></li>
<li><a href="#52-FileSystem">5.2 FileSystem</a> <br>
<ul><li><a href="#521-configured基类和closeable接口">5.2.1 Configured基类和Closeable接口</a></li>
<li><a href="#522-filesystem的内部类和属性">5.2.2 FileSystem的内部类和属性</a></li>
<li><a href="#523-文件系统的获取">5.2.3 文件系统的获取</a></li>
<li><a href="#524-文件系统的关闭">5.2.4 文件系统的关闭</a></li>
<li><a href="#525-读取数据">5.2.5 读取数据</a></li>
<li><a href="#526-写入数据">5.2.6 写入数据</a></li>
<li><a href="#527-文件操作">5.2.7 文件操作</a></li>
<li><a href="#528-查询文件系统">5.2.8 查询文件系统</a></li>
<li><a href="#529-其它方法">5.2.9 其它方法</a></li></ul></li>
<li><a href="#53-filterfilesystem">5.3 FilterFileSystem</a></li>
<li><a href="#54-checksumfilesystem">5.4 ChecksumFileSystem</a></li>
<li><a href="#55-localfilesystem">5.5 LocalFileSystem</a></li>
</ul>

<h3 id="51-fs中的接口">5.1 fs中的接口</h3>

<p>org.apache.hadoop.fs包中的接口不多，有：</p>

<ul>
<li>CanSetDropBehind - 配置流是否应该丢掉缓存</li>
<li>CanSetReadahead - 设置预读取流</li>
<li>FsConstants     表示文件系统有关的常量。</li>
<li>PathFilter - 测试抽象路径名是否应该包含在某个抽象路径名表中</li>
<li>PositionedReadable 和Seekable 提供了随机读写功能</li>
<li>Syncable        文件同步</li>
<li>VolumeId - 标识一个硬盘位置的接口</li>
</ul>

<h3 id="52-filesystem">5.2 FileSystem</h3>

<p>FileSystem 的类图如图5-1: <br>
<img src="./images/5-1.jpg" alt="img" title=""></p>

<p>由此可见FileSystem 是一个很大的抽象类。在fs 包中，最重要的可以说是FileSystem 抽象类。 <br>
它定义了文件系统中涉及的一些基本操作，如：create，rename ，delete… <br>
另外包括一些分布式文件系统具有的操作：copyFromLocalFile, copyToLocalFile,… <br>
类似于Ftp 中put 和get 操作。 <br>
LocalFileSystem 和DistributedFileSystem，继承于此类， <br>
分别实现了对本地文件系统和分布式文件系统的FileSystem API。</p>

<h4 id="521-configured基类和closeable接口">5.2.1 Configured基类和Closeable接口</h4>

<p>FileSystem 抽象类从Configured 基类派生，并实现了Closeable 接口。 <br>
Configured 基类的源代码如下，该基类仅是简单的提供了访问配置文件的方法。</p>

<pre class="prettyprint prettyprinted"><code class="language-java"><span class="kwd">public</span><span class="pln"> </span><span class="kwd">class</span><span class="pln"> </span><span class="typ">Configured</span><span class="pln"> </span><span class="kwd">implements</span><span class="pln"> </span><span class="typ">Configurable</span><span class="pln"> </span><span class="pun">{</span><span class="pln">

  </span><span class="kwd">private</span><span class="pln"> </span><span class="typ">Configuration</span><span class="pln"> conf</span><span class="pun">;</span><span class="pln">

  </span><span class="com">/** Construct a Configured. */</span><span class="pln">
  </span><span class="kwd">public</span><span class="pln"> </span><span class="typ">Configured</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">(</span><span class="kwd">null</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  </span><span class="com">/** Construct a Configured. */</span><span class="pln">
  </span><span class="kwd">public</span><span class="pln"> </span><span class="typ">Configured</span><span class="pun">(</span><span class="typ">Configuration</span><span class="pln"> conf</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    setConf</span><span class="pun">(</span><span class="pln">conf</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  </span><span class="com">// inherit javadoc</span><span class="pln">
  </span><span class="lit">@Override</span><span class="pln">
  </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> setConf</span><span class="pun">(</span><span class="typ">Configuration</span><span class="pln"> conf</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">conf </span><span class="pun">=</span><span class="pln"> conf</span><span class="pun">;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  </span><span class="com">// inherit javadoc</span><span class="pln">
  </span><span class="lit">@Override</span><span class="pln">
  </span><span class="kwd">public</span><span class="pln"> </span><span class="typ">Configuration</span><span class="pln"> getConf</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> conf</span><span class="pun">;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

</span><span class="pun">}</span></code></pre>

<p>Closeable接口的代码如下, 该接口主要是声明关闭流的close方法, 调用close方法释放与该流相关的所有系统资源</p>

<pre class="prettyprint prettyprinted"><code class="language-java"><span class="kwd">public</span><span class="pln"> interface </span><span class="typ">Closeable</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">AutoCloseable</span><span class="pln"> </span><span class="pun">{</span><span class="pln">

    </span><span class="com">/**
     * Closes this stream and releases any system resources associated
     * with it. If the stream is already closed then invoking this
     * method has no effect.
     *
     * @throws IOException if an I/O error occurs
     */</span><span class="pln">
    </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> close</span><span class="pun">()</span><span class="pln"> </span><span class="kwd">throws</span><span class="pln"> </span><span class="typ">IOException</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span></code></pre>

<h4 id="522-filesystem的内部类和属性">5.2.2 FileSystem的内部类和属性</h4>

<p>内部类有Cache, Statistics.</p>

<p>FileSystem内部的属性见下面代码:</p>

<pre class="prettyprint prettyprinted"><code class="language-java"><span class="kwd">public</span><span class="pln"> </span><span class="kwd">static</span><span class="pln"> </span><span class="kwd">final</span><span class="pln"> </span><span class="typ">String</span><span class="pln"> FS_DEFAULT_NAME_KEY </span><span class="pun">=</span><span class="pln">
                 </span><span class="typ">CommonConfigurationKeys</span><span class="pun">.</span><span class="pln">FS_DEFAULT_NAME_KEY</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">static</span><span class="pln"> </span><span class="kwd">final</span><span class="pln"> </span><span class="typ">String</span><span class="pln"> DEFAULT_FS </span><span class="pun">=</span><span class="pln">
                 </span><span class="typ">CommonConfigurationKeys</span><span class="pun">.</span><span class="pln">FS_DEFAULT_NAME_DEFAULT</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">static</span><span class="pln"> </span><span class="kwd">final</span><span class="pln"> </span><span class="typ">Log</span><span class="pln"> LOG </span><span class="pun">=</span><span class="pln"> </span><span class="typ">LogFactory</span><span class="pun">.</span><span class="pln">getLog</span><span class="pun">(</span><span class="typ">FileSystem</span><span class="pun">.</span><span class="kwd">class</span><span class="pun">);</span><span class="pln">

</span><span class="com">/**
 * Priority of the FileSystem shutdown hook.
 */</span><span class="pln">
</span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">static</span><span class="pln"> </span><span class="kwd">final</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> SHUTDOWN_HOOK_PRIORITY </span><span class="pun">=</span><span class="pln"> </span><span class="lit">10</span><span class="pun">;</span><span class="pln">

</span><span class="com">/** FileSystem cache */</span><span class="pln">
</span><span class="kwd">static</span><span class="pln"> </span><span class="kwd">final</span><span class="pln"> </span><span class="typ">Cache</span><span class="pln"> CACHE </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Cache</span><span class="pun">();</span><span class="pln">

</span><span class="com">/** The key this instance is stored under in the cache. */</span><span class="pln">
</span><span class="kwd">private</span><span class="pln"> </span><span class="typ">Cache</span><span class="pun">.</span><span class="typ">Key</span><span class="pln"> key</span><span class="pun">;</span><span class="pln">

</span><span class="com">/** Recording statistics per a FileSystem class */</span><span class="pln">
</span><span class="kwd">private</span><span class="pln"> </span><span class="kwd">static</span><span class="pln"> </span><span class="kwd">final</span><span class="pln"> </span><span class="typ">Map</span><span class="pun">&lt;</span><span class="typ">Class</span><span class="pun">&lt;?</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">FileSystem</span><span class="pun">&gt;,</span><span class="pln"> </span><span class="typ">Statistics</span><span class="pun">&gt;</span><span class="pln"> 
  statisticsTable </span><span class="pun">=</span><span class="pln">
    </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">IdentityHashMap</span><span class="pun">&lt;</span><span class="typ">Class</span><span class="pun">&lt;?</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">FileSystem</span><span class="pun">&gt;,</span><span class="pln"> </span><span class="typ">Statistics</span><span class="pun">&gt;();</span><span class="pln">

</span><span class="com">/**
 * The statistics for this file system.
 */</span><span class="pln">
</span><span class="kwd">protected</span><span class="pln"> </span><span class="typ">Statistics</span><span class="pln"> statistics</span><span class="pun">;</span><span class="pln">

</span><span class="com">/**
 * A cache of files that should be deleted when filsystem is closed
 * or the JVM is exited.
 */</span><span class="pln">
</span><span class="kwd">private</span><span class="pln"> </span><span class="typ">Set</span><span class="pun">&lt;</span><span class="typ">Path</span><span class="pun">&gt;</span><span class="pln"> deleteOnExit </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">TreeSet</span><span class="pun">&lt;</span><span class="typ">Path</span><span class="pun">&gt;();</span><span class="pln">

</span><span class="kwd">boolean</span><span class="pln"> resolveSymlinks</span><span class="pun">;</span></code></pre>

<h5 id="5221-cache">5.2.2.1 Cache</h5>

<p>FileSystem 内部类 Cache 用来缓存文件系统对象。</p>

<p>Cache成员, 方法见下图:</p>

<p><img src="./images/5-2.png" alt="img" title=""></p>

<p>在检索文件系统时,如果缓存未被禁用,则会首先从缓存中读取。</p>

<p>Cache 中有两个内部类,ClientFinalizer 和 Key。</p>

<p>ClientFinalizer类:</p>

<p><img src="./images/5-3.png" alt="img" title=""></p>

<p>ClientFinalizer类为一线程类,当Java虚拟机停止运行时,该线程才会运行。而运行时,run <br>
方法会调用 Cache.closeAll(true)方法,进行清理工作。</p>

<p>内部静态类Key,顾名思意,它作为Cache中HashMap<key, filesystem="">的关键字。保存了 <br>
有关文件系统的 Uri 的信息,而其中的各个方法也是简单明了。</key,></p>

<p><img src="./images/5-4.png" alt="img" title=""></p>

<p>Cache类中的集合toAutoClose属性用来表示是否需要自动关闭Key所对应的文件系统。 <br>
Cache方法get()和getUnique()内部仅简单地调用了getInternal()方法。 <br>
其代码所下：</p>

<pre class="prettyprint prettyprinted"><code class="language-java"><span class="kwd">private</span><span class="pln"> </span><span class="typ">FileSystem</span><span class="pln"> getInternal</span><span class="pun">(</span><span class="pln">URI uri</span><span class="pun">,</span><span class="pln"> </span><span class="typ">Configuration</span><span class="pln"> conf</span><span class="pun">,</span><span class="pln"> </span><span class="typ">Key</span><span class="pln"> key</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">throws</span><span class="pln"> </span><span class="typ">IOException</span><span class="pun">{</span><span class="pln">
  </span><span class="typ">FileSystem</span><span class="pln"> fs</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">synchronized</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">this</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    fs </span><span class="pun">=</span><span class="pln"> map</span><span class="pun">.</span><span class="pln">get</span><span class="pun">(</span><span class="pln">key</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">fs </span><span class="pun">!=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> fs</span><span class="pun">;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  fs </span><span class="pun">=</span><span class="pln"> createFileSystem</span><span class="pun">(</span><span class="pln">uri</span><span class="pun">,</span><span class="pln"> conf</span><span class="pun">);</span><span class="pln">
  </span><span class="kwd">synchronized</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">this</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="com">// refetch the lock again</span><span class="pln">
    </span><span class="typ">FileSystem</span><span class="pln"> oldfs </span><span class="pun">=</span><span class="pln"> map</span><span class="pun">.</span><span class="pln">get</span><span class="pun">(</span><span class="pln">key</span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">oldfs </span><span class="pun">!=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="com">// a file system is created while lock is releasing</span><span class="pln">
      fs</span><span class="pun">.</span><span class="pln">close</span><span class="pun">();</span><span class="pln"> </span><span class="com">// close the new file system</span><span class="pln">
      </span><span class="kwd">return</span><span class="pln"> oldfs</span><span class="pun">;</span><span class="pln">  </span><span class="com">// return the old file system</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">

    </span><span class="com">// now insert the new file system into the map</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">map</span><span class="pun">.</span><span class="pln">isEmpty</span><span class="pun">()</span><span class="pln">
            </span><span class="pun">&amp;&amp;</span><span class="pln"> </span><span class="pun">!</span><span class="typ">ShutdownHookManager</span><span class="pun">.</span><span class="pln">get</span><span class="pun">().</span><span class="pln">isShutdownInProgress</span><span class="pun">())</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="typ">ShutdownHookManager</span><span class="pun">.</span><span class="pln">get</span><span class="pun">().</span><span class="pln">addShutdownHook</span><span class="pun">(</span><span class="pln">clientFinalizer</span><span class="pun">,</span><span class="pln"> SHUTDOWN_HOOK_PRIORITY</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
    fs</span><span class="pun">.</span><span class="pln">key </span><span class="pun">=</span><span class="pln"> key</span><span class="pun">;</span><span class="pln">
    map</span><span class="pun">.</span><span class="pln">put</span><span class="pun">(</span><span class="pln">key</span><span class="pun">,</span><span class="pln"> fs</span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">conf</span><span class="pun">.</span><span class="pln">getBoolean</span><span class="pun">(</span><span class="str">"fs.automatic.close"</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">))</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
          toAutoClose</span><span class="pun">.</span><span class="pln">add</span><span class="pun">(</span><span class="pln">key</span><span class="pun">);</span><span class="pln">
        </span><span class="pun">}</span><span class="pln">
        </span><span class="kwd">return</span><span class="pln"> fs</span><span class="pun">;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span></code></pre>

<p>在getInternal中调用FileSystem.createFileSystem打开一个文件系统</p>

<pre class="prettyprint prettyprinted"><code class="language-java"><span class="kwd">private</span><span class="pln"> </span><span class="kwd">static</span><span class="pln"> </span><span class="typ">FileSystem</span><span class="pln"> createFileSystem</span><span class="pun">(</span><span class="pln">URI uri</span><span class="pun">,</span><span class="pln"> </span><span class="typ">Configuration</span><span class="pln"> conf
     </span><span class="pun">)</span><span class="pln"> </span><span class="kwd">throws</span><span class="pln"> </span><span class="typ">IOException</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
   </span><span class="typ">Class</span><span class="pun">&lt;?&gt;</span><span class="pln"> clazz </span><span class="pun">=</span><span class="pln"> getFileSystemClass</span><span class="pun">(</span><span class="pln">uri</span><span class="pun">.</span><span class="pln">getScheme</span><span class="pun">(),</span><span class="pln"> conf</span><span class="pun">);</span><span class="pln">
   </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">clazz </span><span class="pun">==</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
     </span><span class="kwd">throw</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">IOException</span><span class="pun">(</span><span class="str">"No FileSystem for scheme: "</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> uri</span><span class="pun">.</span><span class="pln">getScheme</span><span class="pun">());</span><span class="pln">
   </span><span class="pun">}</span><span class="pln">
   </span><span class="typ">FileSystem</span><span class="pln"> fs </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="typ">FileSystem</span><span class="pun">)</span><span class="typ">ReflectionUtils</span><span class="pun">.</span><span class="pln">newInstance</span><span class="pun">(</span><span class="pln">clazz</span><span class="pun">,</span><span class="pln"> conf</span><span class="pun">);</span><span class="pln">
   fs</span><span class="pun">.</span><span class="pln">initialize</span><span class="pun">(</span><span class="pln">uri</span><span class="pun">,</span><span class="pln"> conf</span><span class="pun">);</span><span class="pln">
   </span><span class="kwd">return</span><span class="pln"> fs</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span></code></pre>

<p>ReflectionUtils.newInstance()则利用 Java 的反射机制,调用 clazz 的构造函数,设置配置文件</p>

<p>后,将生成的对象返回。</p>

<p>Cache方法 synchronized void remove(Key key, FileSystem fs)用来从映射 map 中删除相应的 key 和 fs <br>
对应的映射。</p>

<p>Cache方法 synchronized void closeAll(boolean onlyAutomatic) throws IOException 用来删除所有的映 <br>
射,并调用文件系统的 close()方法。当 onlyAutomatic 为 true 时,仅删除在集合 toAutoClose 中含 <br>
有的键值对。</p>

<h4 id="523-文件系统的获取">5.2.3 文件系统的获取</h4>

<p>FileSystem 是一个普通的文件系统API，所以首要任务是检索我们要用的文件系统实例。 <br>
取得FileSystem 实例有三种静态工厂方法get() 。 <br>
这些 get() 方法是Hadoop 0.21版本之前就存在的，但在0.21 版本中又添加了与之功能相同的三个方法newInstance() 。</p>

<p>get() 方法如下：</p>

<pre class="prettyprint prettyprinted"><code class="language-java"><span class="pln">  </span><span class="com">/**
   * Get a filesystem instance based on the uri, the passed
   * configuration and the user
   * @param uri of the filesystem
   * @param conf the configuration to use
   * @param user to perform the get as
   * @return the filesystem instance
   * @throws IOException
   * @throws InterruptedException
   */</span><span class="pln">
  </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">static</span><span class="pln"> </span><span class="typ">FileSystem</span><span class="pln"> get</span><span class="pun">(</span><span class="kwd">final</span><span class="pln"> URI uri</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">final</span><span class="pln"> </span><span class="typ">Configuration</span><span class="pln"> conf</span><span class="pun">,</span><span class="pln">
        </span><span class="kwd">final</span><span class="pln"> </span><span class="typ">String</span><span class="pln"> user</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">throws</span><span class="pln"> </span><span class="typ">IOException</span><span class="pun">,</span><span class="pln"> </span><span class="typ">InterruptedException</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="typ">String</span><span class="pln"> ticketCachePath </span><span class="pun">=</span><span class="pln">
      conf</span><span class="pun">.</span><span class="pln">get</span><span class="pun">(</span><span class="typ">CommonConfigurationKeys</span><span class="pun">.</span><span class="pln">KERBEROS_TICKET_CACHE_PATH</span><span class="pun">);</span><span class="pln">
    </span><span class="typ">UserGroupInformation</span><span class="pln"> ugi </span><span class="pun">=</span><span class="pln">
        </span><span class="typ">UserGroupInformation</span><span class="pun">.</span><span class="pln">getBestUGI</span><span class="pun">(</span><span class="pln">ticketCachePath</span><span class="pun">,</span><span class="pln"> user</span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> ugi</span><span class="pun">.</span><span class="pln">doAs</span><span class="pun">(</span><span class="kwd">new</span><span class="pln"> </span><span class="typ">PrivilegedExceptionAction</span><span class="pun">&lt;</span><span class="typ">FileSystem</span><span class="pun">&gt;()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="lit">@Override</span><span class="pln">
      </span><span class="kwd">public</span><span class="pln"> </span><span class="typ">FileSystem</span><span class="pln"> run</span><span class="pun">()</span><span class="pln"> </span><span class="kwd">throws</span><span class="pln"> </span><span class="typ">IOException</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="kwd">return</span><span class="pln"> get</span><span class="pun">(</span><span class="pln">uri</span><span class="pun">,</span><span class="pln"> conf</span><span class="pun">);</span><span class="pln">
      </span><span class="pun">}</span><span class="pln">
    </span><span class="pun">});</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  </span><span class="com">/**
   * Returns the configured filesystem implementation.
   * @param conf the configuration to use
   */</span><span class="pln">
  </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">static</span><span class="pln"> </span><span class="typ">FileSystem</span><span class="pln"> get</span><span class="pun">(</span><span class="typ">Configuration</span><span class="pln"> conf</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">throws</span><span class="pln"> </span><span class="typ">IOException</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> get</span><span class="pun">(</span><span class="pln">getDefaultUri</span><span class="pun">(</span><span class="pln">conf</span><span class="pun">),</span><span class="pln"> conf</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">static</span><span class="pln"> </span><span class="typ">FileSystem</span><span class="pln"> get</span><span class="pun">(</span><span class="pln">URI uri</span><span class="pun">,</span><span class="pln"> </span><span class="typ">Configuration</span><span class="pln"> conf</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">throws</span><span class="pln"> </span><span class="typ">IOException</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="typ">String</span><span class="pln"> scheme </span><span class="pun">=</span><span class="pln"> uri</span><span class="pun">.</span><span class="pln">getScheme</span><span class="pun">();</span><span class="pln">
    </span><span class="typ">String</span><span class="pln"> authority </span><span class="pun">=</span><span class="pln"> uri</span><span class="pun">.</span><span class="pln">getAuthority</span><span class="pun">();</span><span class="pln">

    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">scheme </span><span class="pun">==</span><span class="pln"> </span><span class="kwd">null</span><span class="pln"> </span><span class="pun">&amp;&amp;</span><span class="pln"> authority </span><span class="pun">==</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">     </span><span class="com">// use default FS</span><span class="pln">
      </span><span class="kwd">return</span><span class="pln"> get</span><span class="pun">(</span><span class="pln">conf</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">

    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">scheme </span><span class="pun">!=</span><span class="pln"> </span><span class="kwd">null</span><span class="pln"> </span><span class="pun">&amp;&amp;</span><span class="pln"> authority </span><span class="pun">==</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">     </span><span class="com">// no authority</span><span class="pln">
      URI defaultUri </span><span class="pun">=</span><span class="pln"> getDefaultUri</span><span class="pun">(</span><span class="pln">conf</span><span class="pun">);</span><span class="pln">
      </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">scheme</span><span class="pun">.</span><span class="pln">equals</span><span class="pun">(</span><span class="pln">defaultUri</span><span class="pun">.</span><span class="pln">getScheme</span><span class="pun">())</span><span class="pln">    </span><span class="com">// if scheme matches default</span><span class="pln">
          </span><span class="pun">&amp;&amp;</span><span class="pln"> defaultUri</span><span class="pun">.</span><span class="pln">getAuthority</span><span class="pun">()</span><span class="pln"> </span><span class="pun">!=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">  </span><span class="com">// &amp; default has authority</span><span class="pln">
        </span><span class="kwd">return</span><span class="pln"> get</span><span class="pun">(</span><span class="pln">defaultUri</span><span class="pun">,</span><span class="pln"> conf</span><span class="pun">);</span><span class="pln">              </span><span class="com">// return default</span><span class="pln">
      </span><span class="pun">}</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">

    </span><span class="typ">String</span><span class="pln"> disableCacheName </span><span class="pun">=</span><span class="pln"> </span><span class="typ">String</span><span class="pun">.</span><span class="pln">format</span><span class="pun">(</span><span class="str">"fs.%s.impl.disable.cache"</span><span class="pun">,</span><span class="pln"> scheme</span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">conf</span><span class="pun">.</span><span class="pln">getBoolean</span><span class="pun">(</span><span class="pln">disableCacheName</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">))</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">return</span><span class="pln"> createFileSystem</span><span class="pun">(</span><span class="pln">uri</span><span class="pun">,</span><span class="pln"> conf</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">

    </span><span class="kwd">return</span><span class="pln"> CACHE</span><span class="pun">.</span><span class="pln">get</span><span class="pun">(</span><span class="pln">uri</span><span class="pun">,</span><span class="pln"> conf</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span></code></pre>

<p>各个newInstance() 方法分别对应一个get() 方法，完成的功能也是一样。</p>

<h4 id="524-文件系统的关闭">5.2.4 文件系统的关闭</h4>

<p>有两个方法来关闭文件系统。closeAll()用来关闭所有的文件系统。 <br>
而close() 只是关闭当前调用该方法的文件系统，代码如下:</p>

<pre class="prettyprint prettyprinted"><code class="language-java"><span class="pln">  </span><span class="com">/**
   * Close all cached filesystems. Be sure those filesystems are not
   * used anymore.
   *
   * @throws IOException
   */</span><span class="pln">
  </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">static</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> closeAll</span><span class="pun">()</span><span class="pln"> </span><span class="kwd">throws</span><span class="pln"> </span><span class="typ">IOException</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    CACHE</span><span class="pun">.</span><span class="pln">closeAll</span><span class="pun">();</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  </span><span class="com">/**
   * No more filesystem operations are needed.  Will
   * release any held locks.
   */</span><span class="pln">
  </span><span class="lit">@Override</span><span class="pln">
  </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> close</span><span class="pun">()</span><span class="pln"> </span><span class="kwd">throws</span><span class="pln"> </span><span class="typ">IOException</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="com">// delete all files that were marked as delete-on-exit.</span><span class="pln">
    processDeleteOnExit</span><span class="pun">();</span><span class="pln">
    CACHE</span><span class="pun">.</span><span class="pln">remove</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">key</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span></code></pre>

<h4 id="525-读取数据">5.2.5 读取数据</h4>

<p>数据的读取就像Java 中的io 一样，首先要获得一个输入流。输入流是通过open()方法获得的。 <br>
抽象方法open()将由各个不同的文件系统重写，如下:</p>

<pre class="prettyprint prettyprinted"><code class="language-java"><span class="pln">  </span><span class="com">/**
   * Opens an FSDataInputStream at the indicated Path.
   * @param f the file name to open
   * @param bufferSize the size of the buffer to be used.
   */</span><span class="pln">
  </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">abstract</span><span class="pln"> </span><span class="typ">FSDataInputStream</span><span class="pln"> open</span><span class="pun">(</span><span class="typ">Path</span><span class="pln"> f</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> bufferSize</span><span class="pun">)</span><span class="pln">
    </span><span class="kwd">throws</span><span class="pln"> </span><span class="typ">IOException</span><span class="pun">;</span><span class="pln">

  </span><span class="kwd">public</span><span class="pln"> </span><span class="typ">FSDataInputStream</span><span class="pln"> open</span><span class="pun">(</span><span class="typ">Path</span><span class="pln"> f</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">throws</span><span class="pln"> </span><span class="typ">IOException</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> open</span><span class="pun">(</span><span class="pln">f</span><span class="pun">,</span><span class="pln"> getConf</span><span class="pun">().</span><span class="pln">getInt</span><span class="pun">(</span><span class="str">"io.file.buffer.size"</span><span class="pun">,</span><span class="pln"> </span><span class="lit">4096</span><span class="pun">));</span><span class="pln">
  </span><span class="pun">}</span></code></pre>

<p>RawLocalFileSystem 的open 实现：</p>

<pre class="prettyprint prettyprinted"><code class="language-java"><span class="pln">  </span><span class="lit">@Override</span><span class="pln">
  </span><span class="kwd">public</span><span class="pln"> </span><span class="typ">FSDataInputStream</span><span class="pln"> open</span><span class="pun">(</span><span class="typ">Path</span><span class="pln"> f</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> bufferSize</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">throws</span><span class="pln"> </span><span class="typ">IOException</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(!</span><span class="pln">exists</span><span class="pun">(</span><span class="pln">f</span><span class="pun">))</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">throw</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">FileNotFoundException</span><span class="pun">(</span><span class="pln">f</span><span class="pun">.</span><span class="pln">toString</span><span class="pun">());</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">FSDataInputStream</span><span class="pun">(</span><span class="kwd">new</span><span class="pln"> </span><span class="typ">BufferedFSInputStream</span><span class="pun">(</span><span class="pln">
        </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">LocalFSFileInputStream</span><span class="pun">(</span><span class="pln">f</span><span class="pun">),</span><span class="pln"> bufferSize</span><span class="pun">));</span><span class="pln">
  </span><span class="pun">}</span></code></pre>

<p>其他文件系统的实现类似。</p>

<h4 id="526-写入数据">5.2.6 写入数据</h4>

<p>向文件系统中写入数据，或新建一个文件，需要获得一个用来写的输出流， <br>
这可以通过以下的多个create()方法来实现。 <br>
这些重载的方法允许我们指定是否强制覆盖已有的文件、 <br>
文件副本数量、写入文件时的缓冲大小、文件块大小以及文件许可等等。</p>

<pre class="prettyprint prettyprinted"><code class="language-java"><span class="pln">  </span><span class="kwd">public</span><span class="pln"> </span><span class="typ">FSDataOutputStream</span><span class="pln"> create</span><span class="pun">(</span><span class="typ">Path</span><span class="pln"> f</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">throws</span><span class="pln"> </span><span class="typ">IOException</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> create</span><span class="pun">(</span><span class="pln">f</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  </span><span class="com">/**
   * Create an FSDataOutputStream at the indicated Path.
   * @param f the file to create
   * @param overwrite if a file with this name already exists, then if true,
   *   the file will be overwritten, and if false an exception will be thrown.
   */</span><span class="pln">
  </span><span class="kwd">public</span><span class="pln"> </span><span class="typ">FSDataOutputStream</span><span class="pln"> create</span><span class="pun">(</span><span class="typ">Path</span><span class="pln"> f</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">boolean</span><span class="pln"> overwrite</span><span class="pun">)</span><span class="pln">
      </span><span class="kwd">throws</span><span class="pln"> </span><span class="typ">IOException</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> create</span><span class="pun">(</span><span class="pln">f</span><span class="pun">,</span><span class="pln"> overwrite</span><span class="pun">,</span><span class="pln"> 
                  getConf</span><span class="pun">().</span><span class="pln">getInt</span><span class="pun">(</span><span class="str">"io.file.buffer.size"</span><span class="pun">,</span><span class="pln"> </span><span class="lit">4096</span><span class="pun">),</span><span class="pln">
                  getDefaultReplication</span><span class="pun">(</span><span class="pln">f</span><span class="pun">),</span><span class="pln">
                  getDefaultBlockSize</span><span class="pun">(</span><span class="pln">f</span><span class="pun">));</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  </span><span class="com">/**
   * Create an FSDataOutputStream at the indicated Path with write-progress
   * reporting.
   * Files are overwritten by default.
   * @param f the file to create
   * @param progress to report progress
   */</span><span class="pln">
  </span><span class="kwd">public</span><span class="pln"> </span><span class="typ">FSDataOutputStream</span><span class="pln"> create</span><span class="pun">(</span><span class="typ">Path</span><span class="pln"> f</span><span class="pun">,</span><span class="pln"> </span><span class="typ">Progressable</span><span class="pln"> progress</span><span class="pun">)</span><span class="pln"> 
      </span><span class="kwd">throws</span><span class="pln"> </span><span class="typ">IOException</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> create</span><span class="pun">(</span><span class="pln">f</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">,</span><span class="pln"> 
                  getConf</span><span class="pun">().</span><span class="pln">getInt</span><span class="pun">(</span><span class="str">"io.file.buffer.size"</span><span class="pun">,</span><span class="pln"> </span><span class="lit">4096</span><span class="pun">),</span><span class="pln">
                  getDefaultReplication</span><span class="pun">(</span><span class="pln">f</span><span class="pun">),</span><span class="pln">
                  getDefaultBlockSize</span><span class="pun">(</span><span class="pln">f</span><span class="pun">),</span><span class="pln"> progress</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  </span><span class="com">/**
   * Create an FSDataOutputStream at the indicated Path.
   * Files are overwritten by default.
   * @param f the file to create
   * @param replication the replication factor
   */</span><span class="pln">
  </span><span class="kwd">public</span><span class="pln"> </span><span class="typ">FSDataOutputStream</span><span class="pln"> create</span><span class="pun">(</span><span class="typ">Path</span><span class="pln"> f</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">short</span><span class="pln"> replication</span><span class="pun">)</span><span class="pln">
      </span><span class="kwd">throws</span><span class="pln"> </span><span class="typ">IOException</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> create</span><span class="pun">(</span><span class="pln">f</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">,</span><span class="pln"> 
                  getConf</span><span class="pun">().</span><span class="pln">getInt</span><span class="pun">(</span><span class="str">"io.file.buffer.size"</span><span class="pun">,</span><span class="pln"> </span><span class="lit">4096</span><span class="pun">),</span><span class="pln">
                  replication</span><span class="pun">,</span><span class="pln">
                  getDefaultBlockSize</span><span class="pun">(</span><span class="pln">f</span><span class="pun">));</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  </span><span class="com">/**
   * Create an FSDataOutputStream at the indicated Path with write-progress
   * reporting.
   * Files are overwritten by default.
   * @param f the file to create
   * @param replication the replication factor
   * @param progress to report progress
   */</span><span class="pln">
  </span><span class="kwd">public</span><span class="pln"> </span><span class="typ">FSDataOutputStream</span><span class="pln"> create</span><span class="pun">(</span><span class="typ">Path</span><span class="pln"> f</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">short</span><span class="pln"> replication</span><span class="pun">,</span><span class="pln"> 
      </span><span class="typ">Progressable</span><span class="pln"> progress</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">throws</span><span class="pln"> </span><span class="typ">IOException</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> create</span><span class="pun">(</span><span class="pln">f</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">,</span><span class="pln"> 
                  getConf</span><span class="pun">().</span><span class="pln">getInt</span><span class="pun">(</span><span class="pln">
                      </span><span class="typ">CommonConfigurationKeysPublic</span><span class="pun">.</span><span class="pln">IO_FILE_BUFFER_SIZE_KEY</span><span class="pun">,</span><span class="pln">
                      </span><span class="typ">CommonConfigurationKeysPublic</span><span class="pun">.</span><span class="pln">IO_FILE_BUFFER_SIZE_DEFAULT</span><span class="pun">),</span><span class="pln">
                  replication</span><span class="pun">,</span><span class="pln">
                  getDefaultBlockSize</span><span class="pun">(</span><span class="pln">f</span><span class="pun">),</span><span class="pln"> progress</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">


  </span><span class="com">/**
   * Create an FSDataOutputStream at the indicated Path.
   * @param f the file name to create
   * @param overwrite if a file with this name already exists, then if true,
   *   the file will be overwritten, and if false an error will be thrown.
   * @param bufferSize the size of the buffer to be used.
   */</span><span class="pln">
  </span><span class="kwd">public</span><span class="pln"> </span><span class="typ">FSDataOutputStream</span><span class="pln"> create</span><span class="pun">(</span><span class="typ">Path</span><span class="pln"> f</span><span class="pun">,</span><span class="pln"> 
                                   </span><span class="kwd">boolean</span><span class="pln"> overwrite</span><span class="pun">,</span><span class="pln">
                                   </span><span class="kwd">int</span><span class="pln"> bufferSize
                                   </span><span class="pun">)</span><span class="pln"> </span><span class="kwd">throws</span><span class="pln"> </span><span class="typ">IOException</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> create</span><span class="pun">(</span><span class="pln">f</span><span class="pun">,</span><span class="pln"> overwrite</span><span class="pun">,</span><span class="pln"> bufferSize</span><span class="pun">,</span><span class="pln"> 
                  getDefaultReplication</span><span class="pun">(</span><span class="pln">f</span><span class="pun">),</span><span class="pln">
                  getDefaultBlockSize</span><span class="pun">(</span><span class="pln">f</span><span class="pun">));</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  </span><span class="com">/**
   * Create an FSDataOutputStream at the indicated Path with write-progress
   * reporting.
   * @param f the path of the file to open
   * @param overwrite if a file with this name already exists, then if true,
   *   the file will be overwritten, and if false an error will be thrown.
   * @param bufferSize the size of the buffer to be used.
   */</span><span class="pln">
  </span><span class="kwd">public</span><span class="pln"> </span><span class="typ">FSDataOutputStream</span><span class="pln"> create</span><span class="pun">(</span><span class="typ">Path</span><span class="pln"> f</span><span class="pun">,</span><span class="pln"> 
                                   </span><span class="kwd">boolean</span><span class="pln"> overwrite</span><span class="pun">,</span><span class="pln">
                                   </span><span class="kwd">int</span><span class="pln"> bufferSize</span><span class="pun">,</span><span class="pln">
                                   </span><span class="typ">Progressable</span><span class="pln"> progress
                                   </span><span class="pun">)</span><span class="pln"> </span><span class="kwd">throws</span><span class="pln"> </span><span class="typ">IOException</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> create</span><span class="pun">(</span><span class="pln">f</span><span class="pun">,</span><span class="pln"> overwrite</span><span class="pun">,</span><span class="pln"> bufferSize</span><span class="pun">,</span><span class="pln"> 
                  getDefaultReplication</span><span class="pun">(</span><span class="pln">f</span><span class="pun">),</span><span class="pln">
                  getDefaultBlockSize</span><span class="pun">(</span><span class="pln">f</span><span class="pun">),</span><span class="pln"> progress</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">


  </span><span class="com">/**
   * Create an FSDataOutputStream at the indicated Path.
   * @param f the file name to open
   * @param overwrite if a file with this name already exists, then if true,
   *   the file will be overwritten, and if false an error will be thrown.
   * @param bufferSize the size of the buffer to be used.
   * @param replication required block replication for the file. 
   */</span><span class="pln">
  </span><span class="kwd">public</span><span class="pln"> </span><span class="typ">FSDataOutputStream</span><span class="pln"> create</span><span class="pun">(</span><span class="typ">Path</span><span class="pln"> f</span><span class="pun">,</span><span class="pln"> 
                                   </span><span class="kwd">boolean</span><span class="pln"> overwrite</span><span class="pun">,</span><span class="pln">
                                   </span><span class="kwd">int</span><span class="pln"> bufferSize</span><span class="pun">,</span><span class="pln">
                                   </span><span class="kwd">short</span><span class="pln"> replication</span><span class="pun">,</span><span class="pln">
                                   </span><span class="kwd">long</span><span class="pln"> blockSize
                                   </span><span class="pun">)</span><span class="pln"> </span><span class="kwd">throws</span><span class="pln"> </span><span class="typ">IOException</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> create</span><span class="pun">(</span><span class="pln">f</span><span class="pun">,</span><span class="pln"> overwrite</span><span class="pun">,</span><span class="pln"> bufferSize</span><span class="pun">,</span><span class="pln"> replication</span><span class="pun">,</span><span class="pln"> blockSize</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  </span><span class="com">/**
   * Create an FSDataOutputStream at the indicated Path with write-progress
   * reporting.
   * @param f the file name to open
   * @param overwrite if a file with this name already exists, then if true,
   *   the file will be overwritten, and if false an error will be thrown.
   * @param bufferSize the size of the buffer to be used.
   * @param replication required block replication for the file. 
   */</span><span class="pln">
  </span><span class="kwd">public</span><span class="pln"> </span><span class="typ">FSDataOutputStream</span><span class="pln"> create</span><span class="pun">(</span><span class="typ">Path</span><span class="pln"> f</span><span class="pun">,</span><span class="pln">
                                            </span><span class="kwd">boolean</span><span class="pln"> overwrite</span><span class="pun">,</span><span class="pln">
                                            </span><span class="kwd">int</span><span class="pln"> bufferSize</span><span class="pun">,</span><span class="pln">
                                            </span><span class="kwd">short</span><span class="pln"> replication</span><span class="pun">,</span><span class="pln">
                                            </span><span class="kwd">long</span><span class="pln"> blockSize</span><span class="pun">,</span><span class="pln">
                                            </span><span class="typ">Progressable</span><span class="pln"> progress
                                            </span><span class="pun">)</span><span class="pln"> </span><span class="kwd">throws</span><span class="pln"> </span><span class="typ">IOException</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">create</span><span class="pun">(</span><span class="pln">f</span><span class="pun">,</span><span class="pln"> </span><span class="typ">FsPermission</span><span class="pun">.</span><span class="pln">getFileDefault</span><span class="pun">().</span><span class="pln">applyUMask</span><span class="pun">(</span><span class="pln">
        </span><span class="typ">FsPermission</span><span class="pun">.</span><span class="pln">getUMask</span><span class="pun">(</span><span class="pln">getConf</span><span class="pun">())),</span><span class="pln"> overwrite</span><span class="pun">,</span><span class="pln"> bufferSize</span><span class="pun">,</span><span class="pln">
        replication</span><span class="pun">,</span><span class="pln"> blockSize</span><span class="pun">,</span><span class="pln"> progress</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  </span><span class="com">/**
   * Create an FSDataOutputStream at the indicated Path with write-progress
   * reporting.
   * @param f the file name to open
   * @param permission
   * @param flags {@link CreateFlag}s to use for this stream.
   * @param bufferSize the size of the buffer to be used.
   * @param replication required block replication for the file.
   * @param blockSize
   * @param progress
   * @throws IOException
   * @see #setPermission(Path, FsPermission)
   */</span><span class="pln">
  </span><span class="kwd">public</span><span class="pln"> </span><span class="typ">FSDataOutputStream</span><span class="pln"> create</span><span class="pun">(</span><span class="typ">Path</span><span class="pln"> f</span><span class="pun">,</span><span class="pln">
      </span><span class="typ">FsPermission</span><span class="pln"> permission</span><span class="pun">,</span><span class="pln">
      </span><span class="typ">EnumSet</span><span class="pun">&lt;</span><span class="typ">CreateFlag</span><span class="pun">&gt;</span><span class="pln"> flags</span><span class="pun">,</span><span class="pln">
      </span><span class="kwd">int</span><span class="pln"> bufferSize</span><span class="pun">,</span><span class="pln">
      </span><span class="kwd">short</span><span class="pln"> replication</span><span class="pun">,</span><span class="pln">
      </span><span class="kwd">long</span><span class="pln"> blockSize</span><span class="pun">,</span><span class="pln">
      </span><span class="typ">Progressable</span><span class="pln"> progress</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">throws</span><span class="pln"> </span><span class="typ">IOException</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> create</span><span class="pun">(</span><span class="pln">f</span><span class="pun">,</span><span class="pln"> permission</span><span class="pun">,</span><span class="pln"> flags</span><span class="pun">,</span><span class="pln"> bufferSize</span><span class="pun">,</span><span class="pln"> replication</span><span class="pun">,</span><span class="pln">
        blockSize</span><span class="pun">,</span><span class="pln"> progress</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  </span><span class="com">/**
   * Create an FSDataOutputStream at the indicated Path with a custom
   * checksum option
   * @param f the file name to open
   * @param permission
   * @param flags {@link CreateFlag}s to use for this stream.
   * @param bufferSize the size of the buffer to be used.
   * @param replication required block replication for the file.
   * @param blockSize
   * @param progress
   * @param checksumOpt checksum parameter. If null, the values
   *        found in conf will be used.
   * @throws IOException
   * @see #setPermission(Path, FsPermission)
   */</span><span class="pln">
  </span><span class="kwd">public</span><span class="pln"> </span><span class="typ">FSDataOutputStream</span><span class="pln"> create</span><span class="pun">(</span><span class="typ">Path</span><span class="pln"> f</span><span class="pun">,</span><span class="pln">
      </span><span class="typ">FsPermission</span><span class="pln"> permission</span><span class="pun">,</span><span class="pln">
      </span><span class="typ">EnumSet</span><span class="pun">&lt;</span><span class="typ">CreateFlag</span><span class="pun">&gt;</span><span class="pln"> flags</span><span class="pun">,</span><span class="pln">
      </span><span class="kwd">int</span><span class="pln"> bufferSize</span><span class="pun">,</span><span class="pln">
      </span><span class="kwd">short</span><span class="pln"> replication</span><span class="pun">,</span><span class="pln">
      </span><span class="kwd">long</span><span class="pln"> blockSize</span><span class="pun">,</span><span class="pln">
      </span><span class="typ">Progressable</span><span class="pln"> progress</span><span class="pun">,</span><span class="pln">
      </span><span class="typ">ChecksumOpt</span><span class="pln"> checksumOpt</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">throws</span><span class="pln"> </span><span class="typ">IOException</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="com">// Checksum options are ignored by default. The file systems that</span><span class="pln">
    </span><span class="com">// implement checksum need to override this method. The full</span><span class="pln">
    </span><span class="com">// support is currently only available in DFS.</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> create</span><span class="pun">(</span><span class="pln">f</span><span class="pun">,</span><span class="pln"> permission</span><span class="pun">,</span><span class="pln"> flags</span><span class="pun">.</span><span class="pln">contains</span><span class="pun">(</span><span class="typ">CreateFlag</span><span class="pun">.</span><span class="pln">OVERWRITE</span><span class="pun">),</span><span class="pln"> 
        bufferSize</span><span class="pun">,</span><span class="pln"> replication</span><span class="pun">,</span><span class="pln"> blockSize</span><span class="pun">,</span><span class="pln"> progress</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span></code></pre>

<p>由此可见，各个create 方法最终都是调用了抽象方法create。</p>

<pre class="prettyprint prettyprinted"><code class="language-java"><span class="pln">  </span><span class="com">/**
   * Create an FSDataOutputStream at the indicated Path with write-progress
   * reporting.
   * @param f the file name to open
   * @param permission
   * @param overwrite if a file with this name already exists, then if true,
   *   the file will be overwritten, and if false an error will be thrown.
   * @param bufferSize the size of the buffer to be used.
   * @param replication required block replication for the file.
   * @param blockSize
   * @param progress
   * @throws IOException
   * @see #setPermission(Path, FsPermission)
   */</span><span class="pln">
  </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">abstract</span><span class="pln"> </span><span class="typ">FSDataOutputStream</span><span class="pln"> create</span><span class="pun">(</span><span class="typ">Path</span><span class="pln"> f</span><span class="pun">,</span><span class="pln">
      </span><span class="typ">FsPermission</span><span class="pln"> permission</span><span class="pun">,</span><span class="pln">
      </span><span class="kwd">boolean</span><span class="pln"> overwrite</span><span class="pun">,</span><span class="pln">
      </span><span class="kwd">int</span><span class="pln"> bufferSize</span><span class="pun">,</span><span class="pln">
      </span><span class="kwd">short</span><span class="pln"> replication</span><span class="pun">,</span><span class="pln">
      </span><span class="kwd">long</span><span class="pln"> blockSize</span><span class="pun">,</span><span class="pln">
      </span><span class="typ">Progressable</span><span class="pln"> progress</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">throws</span><span class="pln"> </span><span class="typ">IOException</span><span class="pun">;</span></code></pre>

<p>还有一个用于传递回调接口的重载方法Progressable，如此一来，我们所写的应用就会被告知 <br>
数据写入数据节点的进度，Progressable接口的代码片段如下：</p>

<pre class="prettyprint prettyprinted"><code class="language-java"><span class="com">/**
 * A facility for reporting progress.
 * 
 * &lt;p&gt;Clients and/or applications can use the provided &lt;code&gt;Progressable&lt;/code&gt;
 * to explicitly report progress to the Hadoop framework. This is especially
 * important for operations which take significant amount of time since,
 * in-lieu of the reported progress, the framework has to assume that an error
 * has occured and time-out the operation.&lt;/p&gt;
 */</span><span class="pln">
</span><span class="lit">@InterfaceAudience</span><span class="pun">.</span><span class="typ">Public</span><span class="pln">
</span><span class="lit">@InterfaceStability</span><span class="pun">.</span><span class="typ">Stable</span><span class="pln">
</span><span class="kwd">public</span><span class="pln"> interface </span><span class="typ">Progressable</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="com">/**
   * Report progress to the Hadoop framework.
   */</span><span class="pln">
  </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> progress</span><span class="pun">();</span><span class="pln">
</span><span class="pun">}</span></code></pre>

<p>新建文件的另一种方法是使用append() 在一个已有文件中追加( 也有一些其他重载版本) 。 <br>
重要的是抽象方法append() 。同抽象方法create 一样，各个派生类需要重写. 代码如下:</p>

<pre class="prettyprint prettyprinted"><code class="language-java"><span class="pln">  </span><span class="com">/**
   * Append to an existing file (optional operation).
   * Same as append(f, getConf().getInt("io.file.buffer.size", 4096), null)
   * @param f the existing file to be appended.
   * @throws IOException
   */</span><span class="pln">
  </span><span class="kwd">public</span><span class="pln"> </span><span class="typ">FSDataOutputStream</span><span class="pln"> append</span><span class="pun">(</span><span class="typ">Path</span><span class="pln"> f</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">throws</span><span class="pln"> </span><span class="typ">IOException</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> append</span><span class="pun">(</span><span class="pln">f</span><span class="pun">,</span><span class="pln"> getConf</span><span class="pun">().</span><span class="pln">getInt</span><span class="pun">(</span><span class="str">"io.file.buffer.size"</span><span class="pun">,</span><span class="pln"> </span><span class="lit">4096</span><span class="pun">),</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  </span><span class="com">/**
   * Append to an existing file (optional operation).
   * Same as append(f, bufferSize, null).
   * @param f the existing file to be appended.
   * @param bufferSize the size of the buffer to be used.
   * @throws IOException
   */</span><span class="pln">
  </span><span class="kwd">public</span><span class="pln"> </span><span class="typ">FSDataOutputStream</span><span class="pln"> append</span><span class="pun">(</span><span class="typ">Path</span><span class="pln"> f</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> bufferSize</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">throws</span><span class="pln"> </span><span class="typ">IOException</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> append</span><span class="pun">(</span><span class="pln">f</span><span class="pun">,</span><span class="pln"> bufferSize</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  </span><span class="com">/**
   * Append to an existing file (optional operation).
   * @param f the existing file to be appended.
   * @param bufferSize the size of the buffer to be used.
   * @param progress for reporting progress if it is not null.
   * @throws IOException
   */</span><span class="pln">
  </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">abstract</span><span class="pln"> </span><span class="typ">FSDataOutputStream</span><span class="pln"> append</span><span class="pun">(</span><span class="typ">Path</span><span class="pln"> f</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> bufferSize</span><span class="pun">,</span><span class="pln">
      </span><span class="typ">Progressable</span><span class="pln"> progress</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">throws</span><span class="pln"> </span><span class="typ">IOException</span><span class="pun">;</span></code></pre>

<p>同open 一样，不同的文件系统的实现会重新改函数的实现。</p>

<h4 id="527-文件操作">5.2.7 文件操作</h4>

<h5 id="5271-重命名">5.2.7.1 重命名</h5>

<p>文件重命名使用抽象方法rename() 实现，其代码如下所示。 <br>
0.21 版本以前使用非抽象方法rename() 方法实现。 <br>
但现在该方法已经不再推荐使用。</p>

<pre class="prettyprint prettyprinted"><code class="language-java"><span class="pln">  </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">abstract</span><span class="pln"> </span><span class="kwd">boolean</span><span class="pln"> rename</span><span class="pun">(</span><span class="typ">Path</span><span class="pln"> src</span><span class="pun">,</span><span class="pln"> </span><span class="typ">Path</span><span class="pln"> dst</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">throws</span><span class="pln"> </span><span class="typ">IOException</span><span class="pun">;</span><span class="pln">

  </span><span class="com">/**
   * Renames Path src to Path dst
   * &lt;ul&gt;
   * &lt;li
   * &lt;li&gt;Fails if src is a file and dst is a directory.
   * &lt;li&gt;Fails if src is a directory and dst is a file.
   * &lt;li&gt;Fails if the parent of dst does not exist or is a file.
   * &lt;/ul&gt;
   * &lt;p&gt;
   * If OVERWRITE option is not passed as an argument, rename fails
   * if the dst already exists.
   * &lt;p&gt;
   * If OVERWRITE option is passed as an argument, rename overwrites
   * the dst if it is a file or an empty directory. Rename fails if dst is
   * a non-empty directory.
   * &lt;p&gt;
   * Note that atomicity of rename is dependent on the file system
   * implementation. Please refer to the file system documentation for
   * details. This default implementation is non atomic.
   * &lt;p&gt;
   * This method is deprecated since it is a temporary method added to 
   * support the transition from FileSystem to FileContext for user 
   * applications.
   * 
   * @param src path to be renamed
   * @param dst new path after rename
   * @throws IOException on failure
   */</span><span class="pln">
  </span><span class="lit">@Deprecated</span><span class="pln">
  </span><span class="kwd">protected</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> rename</span><span class="pun">(</span><span class="kwd">final</span><span class="pln"> </span><span class="typ">Path</span><span class="pln"> src</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">final</span><span class="pln"> </span><span class="typ">Path</span><span class="pln"> dst</span><span class="pun">,</span><span class="pln">
      </span><span class="kwd">final</span><span class="pln"> </span><span class="typ">Rename</span><span class="pun">...</span><span class="pln"> options</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">throws</span><span class="pln"> </span><span class="typ">IOException</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="com">// Default implementation</span><span class="pln">
    </span><span class="kwd">final</span><span class="pln"> </span><span class="typ">FileStatus</span><span class="pln"> srcStatus </span><span class="pun">=</span><span class="pln"> getFileLinkStatus</span><span class="pun">(</span><span class="pln">src</span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">srcStatus </span><span class="pun">==</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">throw</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">FileNotFoundException</span><span class="pun">(</span><span class="str">"rename source "</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> src </span><span class="pun">+</span><span class="pln"> </span><span class="str">" not found."</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">

    </span><span class="kwd">boolean</span><span class="pln"> overwrite </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">null</span><span class="pln"> </span><span class="pun">!=</span><span class="pln"> options</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="typ">Rename</span><span class="pln"> option </span><span class="pun">:</span><span class="pln"> options</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">option </span><span class="pun">==</span><span class="pln"> </span><span class="typ">Rename</span><span class="pun">.</span><span class="pln">OVERWRITE</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
          overwrite </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">;</span><span class="pln">
        </span><span class="pun">}</span><span class="pln">
      </span><span class="pun">}</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">

    </span><span class="typ">FileStatus</span><span class="pln"> dstStatus</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">try</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      dstStatus </span><span class="pun">=</span><span class="pln"> getFileLinkStatus</span><span class="pun">(</span><span class="pln">dst</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">catch</span><span class="pln"> </span><span class="pun">(</span><span class="typ">IOException</span><span class="pln"> e</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      dstStatus </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">;</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">dstStatus </span><span class="pun">!=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">srcStatus</span><span class="pun">.</span><span class="pln">isDirectory</span><span class="pun">()</span><span class="pln"> </span><span class="pun">!=</span><span class="pln"> dstStatus</span><span class="pun">.</span><span class="pln">isDirectory</span><span class="pun">())</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="kwd">throw</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">IOException</span><span class="pun">(</span><span class="str">"Source "</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> src </span><span class="pun">+</span><span class="pln"> </span><span class="str">" Destination "</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> dst
            </span><span class="pun">+</span><span class="pln"> </span><span class="str">" both should be either file or directory"</span><span class="pun">);</span><span class="pln">
      </span><span class="pun">}</span><span class="pln">
      </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(!</span><span class="pln">overwrite</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="kwd">throw</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">FileAlreadyExistsException</span><span class="pun">(</span><span class="str">"rename destination "</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> dst
            </span><span class="pun">+</span><span class="pln"> </span><span class="str">" already exists."</span><span class="pun">);</span><span class="pln">
      </span><span class="pun">}</span><span class="pln">
      </span><span class="com">// Delete the destination that is a file or an empty directory</span><span class="pln">
      </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">dstStatus</span><span class="pun">.</span><span class="pln">isDirectory</span><span class="pun">())</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="typ">FileStatus</span><span class="pun">[]</span><span class="pln"> list </span><span class="pun">=</span><span class="pln"> listStatus</span><span class="pun">(</span><span class="pln">dst</span><span class="pun">);</span><span class="pln">
        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">list </span><span class="pun">!=</span><span class="pln"> </span><span class="kwd">null</span><span class="pln"> </span><span class="pun">&amp;&amp;</span><span class="pln"> list</span><span class="pun">.</span><span class="pln">length </span><span class="pun">!=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
          </span><span class="kwd">throw</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">IOException</span><span class="pun">(</span><span class="pln">
              </span><span class="str">"rename cannot overwrite non empty destination directory "</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> dst</span><span class="pun">);</span><span class="pln">
        </span><span class="pun">}</span><span class="pln">
      </span><span class="pun">}</span><span class="pln">
      </span><span class="kwd">delete</span><span class="pun">(</span><span class="pln">dst</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">final</span><span class="pln"> </span><span class="typ">Path</span><span class="pln"> parent </span><span class="pun">=</span><span class="pln"> dst</span><span class="pun">.</span><span class="pln">getParent</span><span class="pun">();</span><span class="pln">
      </span><span class="kwd">final</span><span class="pln"> </span><span class="typ">FileStatus</span><span class="pln"> parentStatus </span><span class="pun">=</span><span class="pln"> getFileStatus</span><span class="pun">(</span><span class="pln">parent</span><span class="pun">);</span><span class="pln">
      </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">parentStatus </span><span class="pun">==</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="kwd">throw</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">FileNotFoundException</span><span class="pun">(</span><span class="str">"rename destination parent "</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> parent
            </span><span class="pun">+</span><span class="pln"> </span><span class="str">" not found."</span><span class="pun">);</span><span class="pln">
      </span><span class="pun">}</span><span class="pln">
      </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(!</span><span class="pln">parentStatus</span><span class="pun">.</span><span class="pln">isDirectory</span><span class="pun">())</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="kwd">throw</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">ParentNotDirectoryException</span><span class="pun">(</span><span class="str">"rename destination parent "</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> parent
            </span><span class="pun">+</span><span class="pln"> </span><span class="str">" is a file."</span><span class="pun">);</span><span class="pln">
      </span><span class="pun">}</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(!</span><span class="pln">rename</span><span class="pun">(</span><span class="pln">src</span><span class="pun">,</span><span class="pln"> dst</span><span class="pun">))</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">throw</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">IOException</span><span class="pun">(</span><span class="str">"rename from "</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> src </span><span class="pun">+</span><span class="pln"> </span><span class="str">" to "</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> dst </span><span class="pun">+</span><span class="pln"> </span><span class="str">" failed."</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
  </span><span class="pun">}</span></code></pre>

<h5 id="5272-文件删除">5.2.7.2 文件删除</h5>

<p>删除使用抽象方法delete()实现，其代码如下所示， <br>
0.21 版本以前使用非抽象方法delete()方法实现。 <br>
但现在该方法已经不再推荐使用。</p>

<pre class="prettyprint prettyprinted"><code class="language-java"><span class="pln">  </span><span class="com">/**
   * Delete a file 
   * @deprecated Use {@link #delete(Path, boolean)} instead.
   */</span><span class="pln">
  </span><span class="lit">@Deprecated</span><span class="pln">
  </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">boolean</span><span class="pln"> </span><span class="kwd">delete</span><span class="pun">(</span><span class="typ">Path</span><span class="pln"> f</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">throws</span><span class="pln"> </span><span class="typ">IOException</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">delete</span><span class="pun">(</span><span class="pln">f</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  </span><span class="com">/** Delete a file.
   *
   * @param f the path to delete.
   * @param recursive if path is a directory and set to 
   * true, the directory is deleted else throws an exception. In
   * case of a file the recursive can be set to either true or false. 
   * @return  true if delete is successful else false. 
   * @throws IOException
   */</span><span class="pln">
  </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">abstract</span><span class="pln"> </span><span class="kwd">boolean</span><span class="pln"> </span><span class="kwd">delete</span><span class="pun">(</span><span class="typ">Path</span><span class="pln"> f</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">boolean</span><span class="pln"> recursive</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">throws</span><span class="pln"> </span><span class="typ">IOException</span><span class="pun">;</span></code></pre>

<h5 id="5273-文件或路径测试">5.2.7.3 文件或路径测试</h5>

<pre class="prettyprint prettyprinted"><code class="language-java"><span class="pln">  </span><span class="com">/** Check if exists.
   * @param f source file
   */</span><span class="pln">
  </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">boolean</span><span class="pln"> exists</span><span class="pun">(</span><span class="typ">Path</span><span class="pln"> f</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">throws</span><span class="pln"> </span><span class="typ">IOException</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">try</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">return</span><span class="pln"> getFileStatus</span><span class="pun">(</span><span class="pln">f</span><span class="pun">)</span><span class="pln"> </span><span class="pun">!=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">;</span><span class="pln">
    </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">catch</span><span class="pln"> </span><span class="pun">(</span><span class="typ">FileNotFoundException</span><span class="pln"> e</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">;</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  </span><span class="com">/** True iff the named path is a directory.
   * Note: Avoid using this method. Instead reuse the FileStatus 
   * returned by getFileStatus() or listStatus() methods.
   * @param f path to check
   */</span><span class="pln">
  </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">boolean</span><span class="pln"> isDirectory</span><span class="pun">(</span><span class="typ">Path</span><span class="pln"> f</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">throws</span><span class="pln"> </span><span class="typ">IOException</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">try</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">return</span><span class="pln"> getFileStatus</span><span class="pun">(</span><span class="pln">f</span><span class="pun">).</span><span class="pln">isDirectory</span><span class="pun">();</span><span class="pln">
    </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">catch</span><span class="pln"> </span><span class="pun">(</span><span class="typ">FileNotFoundException</span><span class="pln"> e</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">;</span><span class="pln">               </span><span class="com">// f does not exist</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  </span><span class="com">/** True iff the named path is a regular file.
   * Note: Avoid using this method. Instead reuse the FileStatus 
   * returned by getFileStatus() or listStatus() methods.
   * @param f path to check
   */</span><span class="pln">
  </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">boolean</span><span class="pln"> isFile</span><span class="pun">(</span><span class="typ">Path</span><span class="pln"> f</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">throws</span><span class="pln"> </span><span class="typ">IOException</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">try</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">return</span><span class="pln"> getFileStatus</span><span class="pun">(</span><span class="pln">f</span><span class="pun">).</span><span class="pln">isFile</span><span class="pun">();</span><span class="pln">
    </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">catch</span><span class="pln"> </span><span class="pun">(</span><span class="typ">FileNotFoundException</span><span class="pln"> e</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">;</span><span class="pln">               </span><span class="com">// f does not exist</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
  </span><span class="pun">}</span></code></pre>

<h5 id="5274-文件复制">5.2.7.4 文件复制</h5>

<p>copyFromLocalFile 来实现将文件从本地复制到其它路径 ，FileSystm 中有多个重载的copyFromLocalFile</p>

<pre class="prettyprint prettyprinted"><code class="language-java"><span class="pln">  </span><span class="com">/**
   * The src file is on the local disk.  Add it to FS at
   * the given dst name and the source is kept intact afterwards
   * @param src path
   * @param dst path
   */</span><span class="pln">
  </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> copyFromLocalFile</span><span class="pun">(</span><span class="typ">Path</span><span class="pln"> src</span><span class="pun">,</span><span class="pln"> </span><span class="typ">Path</span><span class="pln"> dst</span><span class="pun">)</span><span class="pln">
    </span><span class="kwd">throws</span><span class="pln"> </span><span class="typ">IOException</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    copyFromLocalFile</span><span class="pun">(</span><span class="kwd">false</span><span class="pun">,</span><span class="pln"> src</span><span class="pun">,</span><span class="pln"> dst</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">


  </span><span class="com">/**
   * The src file is on the local disk.  Add it to FS at
   * the given dst name.
   * delSrc indicates if the source should be removed
   * @param delSrc whether to delete the src
   * @param src path
   * @param dst path
   */</span><span class="pln">
  </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> copyFromLocalFile</span><span class="pun">(</span><span class="kwd">boolean</span><span class="pln"> delSrc</span><span class="pun">,</span><span class="pln"> </span><span class="typ">Path</span><span class="pln"> src</span><span class="pun">,</span><span class="pln"> </span><span class="typ">Path</span><span class="pln"> dst</span><span class="pun">)</span><span class="pln">
    </span><span class="kwd">throws</span><span class="pln"> </span><span class="typ">IOException</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    copyFromLocalFile</span><span class="pun">(</span><span class="pln">delSrc</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">,</span><span class="pln"> src</span><span class="pun">,</span><span class="pln"> dst</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  </span><span class="com">/**
   * The src files are on the local disk.  Add it to FS at
   * the given dst name.
   * delSrc indicates if the source should be removed
   * @param delSrc whether to delete the src
   * @param overwrite whether to overwrite an existing file
   * @param srcs array of paths which are source
   * @param dst path
   */</span><span class="pln">
  </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> copyFromLocalFile</span><span class="pun">(</span><span class="kwd">boolean</span><span class="pln"> delSrc</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">boolean</span><span class="pln"> overwrite</span><span class="pun">,</span><span class="pln"> 
                                </span><span class="typ">Path</span><span class="pun">[]</span><span class="pln"> srcs</span><span class="pun">,</span><span class="pln"> </span><span class="typ">Path</span><span class="pln"> dst</span><span class="pun">)</span><span class="pln">
    </span><span class="kwd">throws</span><span class="pln"> </span><span class="typ">IOException</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="typ">Configuration</span><span class="pln"> conf </span><span class="pun">=</span><span class="pln"> getConf</span><span class="pun">();</span><span class="pln">
    </span><span class="typ">FileUtil</span><span class="pun">.</span><span class="pln">copy</span><span class="pun">(</span><span class="pln">getLocal</span><span class="pun">(</span><span class="pln">conf</span><span class="pun">),</span><span class="pln"> srcs</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">,</span><span class="pln"> dst</span><span class="pun">,</span><span class="pln"> delSrc</span><span class="pun">,</span><span class="pln"> overwrite</span><span class="pun">,</span><span class="pln"> conf</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  </span><span class="com">/**
   * The src file is on the local disk.  Add it to FS at
   * the given dst name.
   * delSrc indicates if the source should be removed
   * @param delSrc whether to delete the src
   * @param overwrite whether to overwrite an existing file
   * @param src path
   * @param dst path
   */</span><span class="pln">
  </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> copyFromLocalFile</span><span class="pun">(</span><span class="kwd">boolean</span><span class="pln"> delSrc</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">boolean</span><span class="pln"> overwrite</span><span class="pun">,</span><span class="pln"> 
                                </span><span class="typ">Path</span><span class="pln"> src</span><span class="pun">,</span><span class="pln"> </span><span class="typ">Path</span><span class="pln"> dst</span><span class="pun">)</span><span class="pln">
    </span><span class="kwd">throws</span><span class="pln"> </span><span class="typ">IOException</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="typ">Configuration</span><span class="pln"> conf </span><span class="pun">=</span><span class="pln"> getConf</span><span class="pun">();</span><span class="pln">
    </span><span class="typ">FileUtil</span><span class="pun">.</span><span class="pln">copy</span><span class="pun">(</span><span class="pln">getLocal</span><span class="pun">(</span><span class="pln">conf</span><span class="pun">),</span><span class="pln"> src</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">,</span><span class="pln"> dst</span><span class="pun">,</span><span class="pln"> delSrc</span><span class="pun">,</span><span class="pln"> overwrite</span><span class="pun">,</span><span class="pln"> conf</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span></code></pre>

<p>copyToLocalFile负责将FS下的文件复制到本地</p>

<pre class="prettyprint prettyprinted"><code class="language-java"><span class="pln">  </span><span class="com">/**
   * The src file is under FS, and the dst is on the local disk.
   * Copy it from FS control to the local dst name.
   * @param src path
   * @param dst path
   */</span><span class="pln">
  </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> copyToLocalFile</span><span class="pun">(</span><span class="typ">Path</span><span class="pln"> src</span><span class="pun">,</span><span class="pln"> </span><span class="typ">Path</span><span class="pln"> dst</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">throws</span><span class="pln"> </span><span class="typ">IOException</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    copyToLocalFile</span><span class="pun">(</span><span class="kwd">false</span><span class="pun">,</span><span class="pln"> src</span><span class="pun">,</span><span class="pln"> dst</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  </span><span class="com">/**
   * The src file is under FS, and the dst is on the local disk.
   * Copy it from FS control to the local dst name.
   * delSrc indicates if the src will be removed or not.
   * @param delSrc whether to delete the src
   * @param src path
   * @param dst path
   */</span><span class="pln">   
  </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> copyToLocalFile</span><span class="pun">(</span><span class="kwd">boolean</span><span class="pln"> delSrc</span><span class="pun">,</span><span class="pln"> </span><span class="typ">Path</span><span class="pln"> src</span><span class="pun">,</span><span class="pln"> </span><span class="typ">Path</span><span class="pln"> dst</span><span class="pun">)</span><span class="pln">
    </span><span class="kwd">throws</span><span class="pln"> </span><span class="typ">IOException</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    copyToLocalFile</span><span class="pun">(</span><span class="pln">delSrc</span><span class="pun">,</span><span class="pln"> src</span><span class="pun">,</span><span class="pln"> dst</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

    </span><span class="com">/**
   * The src file is under FS, and the dst is on the local disk. Copy it from FS
   * control to the local dst name. delSrc indicates if the src will be removed
   * or not. useRawLocalFileSystem indicates whether to use RawLocalFileSystem
   * as local file system or not. RawLocalFileSystem is non crc file system.So,
   * It will not create any crc files at local.
   * 
   * @param delSrc
   *          whether to delete the src
   * @param src
   *          path
   * @param dst
   *          path
   * @param useRawLocalFileSystem
   *          whether to use RawLocalFileSystem as local file system or not.
   * 
   * @throws IOException
   *           - if any IO error
   */</span><span class="pln">
  </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> copyToLocalFile</span><span class="pun">(</span><span class="kwd">boolean</span><span class="pln"> delSrc</span><span class="pun">,</span><span class="pln"> </span><span class="typ">Path</span><span class="pln"> src</span><span class="pun">,</span><span class="pln"> </span><span class="typ">Path</span><span class="pln"> dst</span><span class="pun">,</span><span class="pln">
      </span><span class="kwd">boolean</span><span class="pln"> useRawLocalFileSystem</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">throws</span><span class="pln"> </span><span class="typ">IOException</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="typ">Configuration</span><span class="pln"> conf </span><span class="pun">=</span><span class="pln"> getConf</span><span class="pun">();</span><span class="pln">
    </span><span class="typ">FileSystem</span><span class="pln"> local </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">useRawLocalFileSystem</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      local </span><span class="pun">=</span><span class="pln"> getLocal</span><span class="pun">(</span><span class="pln">conf</span><span class="pun">).</span><span class="pln">getRawFileSystem</span><span class="pun">();</span><span class="pln">
    </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      local </span><span class="pun">=</span><span class="pln"> getLocal</span><span class="pun">(</span><span class="pln">conf</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
    </span><span class="typ">FileUtil</span><span class="pun">.</span><span class="pln">copy</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">,</span><span class="pln"> src</span><span class="pun">,</span><span class="pln"> local</span><span class="pun">,</span><span class="pln"> dst</span><span class="pun">,</span><span class="pln"> delSrc</span><span class="pun">,</span><span class="pln"> conf</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span></code></pre>

<p>moveFromLocalFile负责将本地文件移动到FS的其它位置</p>

<pre class="prettyprint prettyprinted"><code class="language-java"><span class="pln">  </span><span class="com">/**
   * The src files is on the local disk.  Add it to FS at
   * the given dst name, removing the source afterwards.
   * @param srcs path
   * @param dst path
   */</span><span class="pln">
  </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> moveFromLocalFile</span><span class="pun">(</span><span class="typ">Path</span><span class="pun">[]</span><span class="pln"> srcs</span><span class="pun">,</span><span class="pln"> </span><span class="typ">Path</span><span class="pln"> dst</span><span class="pun">)</span><span class="pln">
    </span><span class="kwd">throws</span><span class="pln"> </span><span class="typ">IOException</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    copyFromLocalFile</span><span class="pun">(</span><span class="kwd">true</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">,</span><span class="pln"> srcs</span><span class="pun">,</span><span class="pln"> dst</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  </span><span class="com">/**
   * The src file is on the local disk.  Add it to FS at
   * the given dst name, removing the source afterwards.
   * @param src path
   * @param dst path
   */</span><span class="pln">
  </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> moveFromLocalFile</span><span class="pun">(</span><span class="typ">Path</span><span class="pln"> src</span><span class="pun">,</span><span class="pln"> </span><span class="typ">Path</span><span class="pln"> dst</span><span class="pun">)</span><span class="pln">
    </span><span class="kwd">throws</span><span class="pln"> </span><span class="typ">IOException</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    copyFromLocalFile</span><span class="pun">(</span><span class="kwd">true</span><span class="pun">,</span><span class="pln"> src</span><span class="pun">,</span><span class="pln"> dst</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span></code></pre>

<p>moveToLocalFile将FS下的文件移动到本地</p>

<pre class="prettyprint prettyprinted"><code class="language-java"><span class="pln">  </span><span class="com">/**
   * The src file is under FS, and the dst is on the local disk.
   * Copy it from FS control to the local dst name.
   * Remove the source afterwards
   * @param src path
   * @param dst path
   */</span><span class="pln">
  </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> moveToLocalFile</span><span class="pun">(</span><span class="typ">Path</span><span class="pln"> src</span><span class="pun">,</span><span class="pln"> </span><span class="typ">Path</span><span class="pln"> dst</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">throws</span><span class="pln"> </span><span class="typ">IOException</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    copyToLocalFile</span><span class="pun">(</span><span class="kwd">true</span><span class="pun">,</span><span class="pln"> src</span><span class="pun">,</span><span class="pln"> dst</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span></code></pre>

<p>moveFromLocalFile, moveToLocalFile分别在内部调用copyFromLocalFile, copyToLocalFile方法</p>

<h4 id="528-查询文件系统">5.2.8 查询文件系统</h4>

<h5 id="5281-文件元数据filestatus">5.2.8.1 文件元数据：FileStatus</h5>

<p>任何文件系统的一个重要特征是定位其目录结构及检索其存储的文件和目录信息的能力。 <br>
FileStatus是一个简单的类，封装了文件系统中文件和目录的元数据，包括文件长度、块大小、副 <br>
本、修改时间、所有者以及许可信息。FileStatus实现了Writeable 接口，可以序列化。</p>

<p>类图见图5-5: <br>
<img src="./images/5-5.jpg" alt="img" title=""></p>

<p>FileSystem 的getFileStatus() 提供了获取一个文件或目录的状态对象的方法。</p>

<h5 id="5282-列出文件">5.2.8.2 列出文件</h5>

<p>查找一个文件或目录的信息很实用，但有时我们还需要能够列出目录的内容。这就是listStatus()方法的功能：</p>

<ol>
<li>public abstract FileStatus[] listStatus(Path f) throws IOException</li>
<li>public FileStatus[] listStatus(Path f, PathFilter filter) throws IOException</li>
<li>public FileStatus[] listStatus(Path[] files) throws IOException</li>
<li>public FileStatus[] listStatus(Path[] files, PathFilter filter) throws IOException</li>
</ol>

<p>传入参数是一个文件时，它会简单地返回长度为1 的FileStatus对象的一个数组。当传入参数是一个目录时，它会返回0 或者多个FileStatus对象，代表着此目录所包含的文件和目录。  <br>
重载方法允许我们使用PathFilter 来限制匹配的文件和目录。</p>

<p>如果把路径数组作为参数来调用listStatus 方法，其结果是与依次对每个路径调用此方法， <br>
再将 FileStatus对象数组收集在一个单一数组中的结果是相同的，但是前者更为方便。 <br>
这在建立从文件系统树的不同部分执行的输入文件的列表时很有用.</p>

<h5 id="5283-文件格式">5.2.8.3 文件格式</h5>

<p>在一步操作中处理批量文件，这个要求很常见。 <br>
举例来说，处理日志的MapReduce 作业可能会分析一个月的文件，这些文件被包含在大量目录中。 <br>
Hadoop有一个通配的操作，可以方便地使用通配符在一个表达式中核对多个文件，不需要列举每个文件和目录来指定输入。 <br>
Hadoop为执行通配提供了两个FileSystem 方法：</p>

<ol>
<li>public FileStatus[] globStatus(Path pathPattern) throws IOException</li>
<li>public FileStatus[] globStatus(Path pathPattern,PathFilter filter) throws IOException <br>
globStatus() 返回了其路径匹配于所供格式的FileStatus对象数组，按路径排序。可选的PathFilter命令可以进一步指定限制匹配。</li>
</ol>

<p>正则语法见图5-6:</p>

<p><img src="./images/5-6.png" alt="img" title=""></p>

<p><strong>PathFilter 对象</strong></p>

<p>通配格式不是总能够精确地描述我们想要访问的文件集合。 <br>
比如，使用通配格式排除一个特定的文件就不太可能。 <br>
FileSystem 中的listStatus() 和globStatus() 方法提供了可选的PathFilter 对象， <br>
使我们能够通过编程方式控制匹配：</p>

<p>PathFilter 代码如下:</p>

<pre class="prettyprint prettyprinted"><code class="language-java"><span class="kwd">public</span><span class="pln"> interface </span><span class="typ">PathFilter</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="com">/**
   * Tests whether or not the specified abstract pathname should be
   * included in a pathname list.
   *
   * @param  path  The abstract pathname to be tested
   * @return  &lt;code&gt;true&lt;/code&gt; if and only if &lt;code&gt;pathname&lt;/code&gt;
   *          should be included
   */</span><span class="pln">
  </span><span class="kwd">boolean</span><span class="pln"> accept</span><span class="pun">(</span><span class="typ">Path</span><span class="pln"> path</span><span class="pun">);</span><span class="pln">
</span><span class="pun">}</span></code></pre>

<h4 id="529-其它方法">5.2.9 其它方法</h4>

<ol>
<li>默认的文件系统uri通过public static URI getDefau ltUri(Configuration conf) 来获取； <br>
通过  public static void setDefaultUri(Configuration conf, URI uri) 和public static void setDefaultUri(Configuration conf, String uri)来设置。</li>
<li>当一个文件系统实例被创建后，就需要调用initialize 来初始化。其默认实现仅仅是设置了statistics 属性。</li>
<li>public abstract URI getUri()  用来获取该文件系统对应的Uri。</li>
<li>public static LocalFileSystem getLocal(Configuration conf)  获得本地文件系统。 <br>
在0.21 版本中出现了一个新的方法newInstanceLocal() ，该方法与getLocal 完成完全一样的功能。</li>
<li>public BlockLocation[] getFileBlockLocations(Path p,  long start, long len) throws IOException</li>
<li>public BlockLocation[] getFileBlockLocations(FileStatus file,  long start, long len) throws  IOException <br>
返回file 中从start 开始len 长度的数据所在的块</li>
<li>public FsServerDefaults getSer verDefaults() throws IOException 得到服务器的默认配置。</li>
<li>public boolean setReplication(Path src, short replication)</li>
<li>public Path getHomeDirectory() 等等。</li>
</ol>

<h3 id="53-filterfilesystem">5.3 FilterFileSystem</h3>

<p>FilterFileSystem 的类图如图5-7：</p>

<p><img src="./images/5-7.jpg" alt="img" title=""></p>

<p>FilterFileSystem 类包含了一个其它的文件系统的实例fs ，并将其作为基本的文件系统。 <br>
FilterFileSystem 类几乎将所有重写的方法交给了其内部保存的fs 来处理。 <br>
但在交给fs 处理之前，自己可以做一些处理，以此来实现过滤。</p>

<p>举例代码如下:</p>

<pre class="prettyprint prettyprinted"><code class="language-java"><span class="pln">  </span><span class="com">/** Called after a new FileSystem instance is constructed.
   * @param name a uri whose authority section names the host, port, etc.
   *   for this FileSystem
   * @param conf the configuration
   */</span><span class="pln">
  </span><span class="lit">@Override</span><span class="pln">
  </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> initialize</span><span class="pun">(</span><span class="pln">URI name</span><span class="pun">,</span><span class="pln"> </span><span class="typ">Configuration</span><span class="pln"> conf</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">throws</span><span class="pln"> </span><span class="typ">IOException</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">super</span><span class="pun">.</span><span class="pln">initialize</span><span class="pun">(</span><span class="pln">name</span><span class="pun">,</span><span class="pln"> conf</span><span class="pun">);</span><span class="pln">
    </span><span class="com">// this is less than ideal, but existing filesystems sometimes neglect</span><span class="pln">
    </span><span class="com">// to initialize the embedded filesystem</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">fs</span><span class="pun">.</span><span class="pln">getConf</span><span class="pun">()</span><span class="pln"> </span><span class="pun">==</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      fs</span><span class="pun">.</span><span class="pln">initialize</span><span class="pun">(</span><span class="pln">name</span><span class="pun">,</span><span class="pln"> conf</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
    </span><span class="typ">String</span><span class="pln"> scheme </span><span class="pun">=</span><span class="pln"> name</span><span class="pun">.</span><span class="pln">getScheme</span><span class="pun">();</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(!</span><span class="pln">scheme</span><span class="pun">.</span><span class="pln">equals</span><span class="pun">(</span><span class="pln">fs</span><span class="pun">.</span><span class="pln">getUri</span><span class="pun">().</span><span class="pln">getScheme</span><span class="pun">()))</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      swapScheme </span><span class="pun">=</span><span class="pln"> scheme</span><span class="pun">;</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  </span><span class="com">/** Returns a URI whose scheme and authority identify this FileSystem.*/</span><span class="pln">
  </span><span class="lit">@Override</span><span class="pln">
  </span><span class="kwd">public</span><span class="pln"> URI getUri</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> fs</span><span class="pun">.</span><span class="pln">getUri</span><span class="pun">();</span><span class="pln">
  </span><span class="pun">}</span></code></pre>

<p>其余方法类似</p>

<p>其实FilterFileSystem实现的是<em>装饰器模式</em></p>

<h3 id="54-checksumfilesystem">5.4 ChecksumFileSystem</h3>

<p>ChecksumFileSystem 类为文件系统提供了校验和的功能, 类图见图5-8</p>

<p><img src="./images/5-8.jpg" alt="img" title=""></p>

<p>HDFS 以透明方式校验所有写入它的数据，并在默认设置下，会在读取数据时验证校验和。</p>

<p>针对数据的每个io.bytes.per.checksum 字节，都会创建一个单独的校验和。默认值为512 字节，使用CRC-32校验和，存储开销为1%。</p>

<p>每一个原始文件都有一个校验和文件，比如文件 /a/b/c.txt  对应的校验和文件为/a/b/.c.txt.crc 。 <br>
校验和文件默认是隐藏的文件，即在文件名“c.txt” 前加上一个“. ”，并在文件名“c.txt”后面加上后缀“.crc ”。</p>

<p>ChecksumFileSystem 类中的属性CHECKSUM_VERSION 为写入校验和文件的文件头中的版本号。verifyChecksum 表示是否需要检测校验和。</p>

<p>ChecksumFileSystem 中有两个内部类ChecksumFSInputChecker 和ChecksumFSOutputSummer。详见后面分析。</p>

<p>ChecksumFileSystem 类open 和create 方法的实现如下，仅是简单的创建一个FSDataInputStream和FSDataOutputStream 。</p>

<pre class="prettyprint prettyprinted"><code class="language-java"><span class="pln">  </span><span class="com">/**
   * Opens an FSDataInputStream at the indicated Path.
   * @param f the file name to open
   * @param bufferSize the size of the buffer to be used.
   */</span><span class="pln">
  </span><span class="lit">@Override</span><span class="pln">
  </span><span class="kwd">public</span><span class="pln"> </span><span class="typ">FSDataInputStream</span><span class="pln"> open</span><span class="pun">(</span><span class="typ">Path</span><span class="pln"> f</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> bufferSize</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">throws</span><span class="pln"> </span><span class="typ">IOException</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="typ">FileSystem</span><span class="pln"> fs</span><span class="pun">;</span><span class="pln">
    </span><span class="typ">InputStream</span><span class="pln"> in</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">verifyChecksum</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      fs </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">;</span><span class="pln">
      in </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">ChecksumFSInputChecker</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">,</span><span class="pln"> f</span><span class="pun">,</span><span class="pln"> bufferSize</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      fs </span><span class="pun">=</span><span class="pln"> getRawFileSystem</span><span class="pun">();</span><span class="pln">
      in </span><span class="pun">=</span><span class="pln"> fs</span><span class="pun">.</span><span class="pln">open</span><span class="pun">(</span><span class="pln">f</span><span class="pun">,</span><span class="pln"> bufferSize</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">FSDataBoundedInputStream</span><span class="pun">(</span><span class="pln">fs</span><span class="pun">,</span><span class="pln"> f</span><span class="pun">,</span><span class="pln"> in</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  </span><span class="lit">@Override</span><span class="pln">
  </span><span class="kwd">public</span><span class="pln"> </span><span class="typ">FSDataOutputStream</span><span class="pln"> create</span><span class="pun">(</span><span class="typ">Path</span><span class="pln"> f</span><span class="pun">,</span><span class="pln"> </span><span class="typ">FsPermission</span><span class="pln"> permission</span><span class="pun">,</span><span class="pln">
      </span><span class="kwd">boolean</span><span class="pln"> overwrite</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> bufferSize</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">short</span><span class="pln"> replication</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">long</span><span class="pln"> blockSize</span><span class="pun">,</span><span class="pln">
      </span><span class="typ">Progressable</span><span class="pln"> progress</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">throws</span><span class="pln"> </span><span class="typ">IOException</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> create</span><span class="pun">(</span><span class="pln">f</span><span class="pun">,</span><span class="pln"> permission</span><span class="pun">,</span><span class="pln"> overwrite</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">,</span><span class="pln"> bufferSize</span><span class="pun">,</span><span class="pln">
        replication</span><span class="pun">,</span><span class="pln"> blockSize</span><span class="pun">,</span><span class="pln"> progress</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  </span><span class="kwd">private</span><span class="pln"> </span><span class="typ">FSDataOutputStream</span><span class="pln"> create</span><span class="pun">(</span><span class="typ">Path</span><span class="pln"> f</span><span class="pun">,</span><span class="pln"> </span><span class="typ">FsPermission</span><span class="pln"> permission</span><span class="pun">,</span><span class="pln">
      </span><span class="kwd">boolean</span><span class="pln"> overwrite</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">boolean</span><span class="pln"> createParent</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> bufferSize</span><span class="pun">,</span><span class="pln">
      </span><span class="kwd">short</span><span class="pln"> replication</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">long</span><span class="pln"> blockSize</span><span class="pun">,</span><span class="pln">
      </span><span class="typ">Progressable</span><span class="pln"> progress</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">throws</span><span class="pln"> </span><span class="typ">IOException</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="typ">Path</span><span class="pln"> parent </span><span class="pun">=</span><span class="pln"> f</span><span class="pun">.</span><span class="pln">getParent</span><span class="pun">();</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">parent </span><span class="pun">!=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(!</span><span class="pln">createParent </span><span class="pun">&amp;&amp;</span><span class="pln"> </span><span class="pun">!</span><span class="pln">exists</span><span class="pun">(</span><span class="pln">parent</span><span class="pun">))</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="kwd">throw</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">FileNotFoundException</span><span class="pun">(</span><span class="str">"Parent directory doesn't exist: "</span><span class="pln">
            </span><span class="pun">+</span><span class="pln"> parent</span><span class="pun">);</span><span class="pln">
      </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(!</span><span class="pln">mkdirs</span><span class="pun">(</span><span class="pln">parent</span><span class="pun">))</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="kwd">throw</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">IOException</span><span class="pun">(</span><span class="str">"Mkdirs failed to create "</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> parent</span><span class="pun">);</span><span class="pln">
      </span><span class="pun">}</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
    </span><span class="kwd">final</span><span class="pln"> </span><span class="typ">FSDataOutputStream</span><span class="pln"> out</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">writeChecksum</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      out </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">FSDataOutputStream</span><span class="pun">(</span><span class="pln">
          </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">ChecksumFSOutputSummer</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">,</span><span class="pln"> f</span><span class="pun">,</span><span class="pln"> overwrite</span><span class="pun">,</span><span class="pln"> bufferSize</span><span class="pun">,</span><span class="pln"> replication</span><span class="pun">,</span><span class="pln">
              blockSize</span><span class="pun">,</span><span class="pln"> progress</span><span class="pun">),</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      out </span><span class="pun">=</span><span class="pln"> fs</span><span class="pun">.</span><span class="pln">create</span><span class="pun">(</span><span class="pln">f</span><span class="pun">,</span><span class="pln"> permission</span><span class="pun">,</span><span class="pln"> overwrite</span><span class="pun">,</span><span class="pln"> bufferSize</span><span class="pun">,</span><span class="pln"> replication</span><span class="pun">,</span><span class="pln">
          blockSize</span><span class="pun">,</span><span class="pln"> progress</span><span class="pun">);</span><span class="pln">
      </span><span class="com">// remove the checksum file since we aren't writing one</span><span class="pln">
      </span><span class="typ">Path</span><span class="pln"> checkFile </span><span class="pun">=</span><span class="pln"> getChecksumFile</span><span class="pun">(</span><span class="pln">f</span><span class="pun">);</span><span class="pln">
      </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">fs</span><span class="pun">.</span><span class="pln">exists</span><span class="pun">(</span><span class="pln">checkFile</span><span class="pun">))</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        fs</span><span class="pun">.</span><span class="kwd">delete</span><span class="pun">(</span><span class="pln">checkFile</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">);</span><span class="pln">
      </span><span class="pun">}</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">permission </span><span class="pun">!=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      setPermission</span><span class="pun">(</span><span class="pln">f</span><span class="pun">,</span><span class="pln"> permission</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> out</span><span class="pun">;</span><span class="pln">
  </span><span class="pun">}</span></code></pre>

<h3 id="55-localfilesystem">5.5 LocalFileSystem</h3>

<p>类图如图5-9</p>

<p><img src="./images/5-9.jpg" alt="img" title=""></p>

<p>LocalFileSystem 从ChecksumFileSystem 类派生，主要实现其它一些支持校验和文件系统的API。</p>

<p>LocalFileSystem 有一个属性rfs，用来表原生的文件系统。LocalFileSystem 重写了一些方法， <br>
如copyFromLocalFile 和copyToLocalFile 等。</p>

<h2 id="6-输入输出流分析">6 输入输出流分析</h2>

<ul>
<li><a href="#61-fsinputstream抽象类">6.1 FSInputStream抽象类</a></li>
<li><a href="#62-输出流">6.2 输出流</a></li>
<li><a href="#63-fsinputchecker">6.3 FSInputChecker</a></li>
<li><a href="#64-fsoutputsummer">6.4 FSOutputSummer</a></li>
<li><a href="#65-fsdatainputstream">6.5 FSDataInputStream</a></li>
<li><a href="#66-fsdataoutputstream">6.6 FSDataOutputStream</a></li>
</ul><div class="se-section-delimiter"></div>

<h3 id="61-fsinputstream抽象类">6.1 FSInputStream抽象类</h3>

<h3 id="62-输出流">6.2 输出流</h3>

<h3 id="63-fsinputchecker">6.3 FSInputChecker</h3>

<h3 id="64-fsoutputsummer">6.4 FSOutputSummer</h3>

<h3 id="65-fsdatainputstream">6.5 FSDataInputStream</h3>

<h3 id="66-fsdataoutputstream">6.6 FSDataOutputStream</h3><div class="se-section-delimiter"></div>

<h2 id="7-abstractfilesystem分析">7 AbstractFileSystem分析</h2>

<ul>
<li><a href="#71-abstractfilesystem抽象类">7.1 AbstractFileSystem抽象类</a></li>
<li><a href="#72-filterfs抽象类">7.2 FilterFs抽象类</a></li>
<li><a href="#73-checksumfs抽象类">7.3 ChecksumFs抽象类</a></li>
<li><a href="#74-localfs类">7.4 LocalFs类</a></li>
<li><a href="#75-delegatetofilesystem">7.5 DelegateToFileSystem</a></li>
<li><a href="#76-filecontext类">7.6 FileContext类</a></li>
</ul>

<p>在分析该类层次结构时，可以将AbstractFileSystem 与FileSystem 对应，FilterFs 与FilerFileSystem 对应， <br>
ChecksumFs与ChecksumFileSystem 对应，LocalFs与LocalFileSystem 对应，RawLocalFs与RawLocalFileSystem 对应。 <br>
他们完成的功能及其相似。</p>

<h3 id="71-abstractfilesystem抽象类">7.1 AbstractFileSystem抽象类</h3>

<p>AbstractFileSystem 是0.21 版本新出现的API，应该是用来替代FileSystem 的。 <br>
该类为 Hadoop文件系统的实现提供了一个接口。AbstractFileSystem 是一个抽象类。 <br>
它与FileSystem 有很多同名的方法。这些同名的方法完成相同的功能。 <br>
比如 get，create 等等。其它的方法大都是抽象方法。</p>

<p>图7-1: <br>
<img src="./images/7-1.jpg" alt="img" title=""></p>

<p>get 方法调用了createFileSystm 方法实现。 <br>
而createFileSystm 方法实现与FileSystm的createFileSystm 可以说是完全一样。 <br>
create 方法首先解析参数，然后调用createInternal 抽象方法。</p>

<h3 id="72-filterfs抽象类">7.2 FilterFs抽象类</h3>

<p>图7-2:</p>

<p><img src="./images/7-2.png" alt="img" title=""></p>

<p>FilterFs也是一个抽象类，它同FilterFileSystem 完全一样，只是拥有一个AbstractFileSystem类型的属性myFs。 <br>
FilterFs将其作为基本的文件系统。FilterFs类几乎将所有重写的方法交给了其内部保存的myFs来处理。 <br>
但在交给 myFs处理之前，自己可以做一些处理，以此来实现过滤。如：</p>

<pre class="prettyprint prettyprinted"><code class="language-java"><span class="kwd">public</span><span class="pln"> </span><span class="typ">FSDataOutputStream</span><span class="pln"> createInternal</span><span class="pun">(</span><span class="typ">Path</span><span class="pln"> f</span><span class="pun">,</span><span class="pln">
    </span><span class="typ">EnumSet</span><span class="pun">&lt;</span><span class="typ">CreateFlag</span><span class="pun">&gt;</span><span class="pln"> flag</span><span class="pun">,</span><span class="pln"> </span><span class="typ">FsPermission</span><span class="pln"> absolutePermission</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> bufferSize</span><span class="pun">,</span><span class="pln">
    </span><span class="kwd">short</span><span class="pln"> replication</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">long</span><span class="pln"> blockSize</span><span class="pun">,</span><span class="pln"> </span><span class="typ">Progressable</span><span class="pln"> progress</span><span class="pun">,</span><span class="pln">
    </span><span class="typ">ChecksumOpt</span><span class="pln"> checksumOpt</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">boolean</span><span class="pln"> createParent</span><span class="pun">)</span><span class="pln"> 
      </span><span class="kwd">throws</span><span class="pln"> </span><span class="typ">IOException</span><span class="pun">,</span><span class="pln"> </span><span class="typ">UnresolvedLinkException</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    checkPath</span><span class="pun">(</span><span class="pln">f</span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> myFs</span><span class="pun">.</span><span class="pln">createInternal</span><span class="pun">(</span><span class="pln">f</span><span class="pun">,</span><span class="pln"> flag</span><span class="pun">,</span><span class="pln"> absolutePermission</span><span class="pun">,</span><span class="pln"> bufferSize</span><span class="pun">,</span><span class="pln">
        replication</span><span class="pun">,</span><span class="pln"> blockSize</span><span class="pun">,</span><span class="pln"> progress</span><span class="pun">,</span><span class="pln"> checksumOpt</span><span class="pun">,</span><span class="pln"> createParent</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span></code></pre>

<h3 id="73-checksumfs抽象类">7.3 ChecksumFs抽象类</h3>

<p>ChecksumFs抽象类的实现与ChecksumFileSystem 的实现完全一样。 <br>
只是ChecksumFs使用的是ChecksumFs.ChecksumFSInputStream ， <br>
而ChecksumFileSystem使用的是ChecksumFileSystem.ChecksumFSInputStream。</p>

<p>图7-3:</p>

<p><img src="./images/7-3.png" alt="img" title=""></p>

<h3 id="74-localfs类">7.4 LocalFs类</h3>

<p>LocalFs仅仅有两个构造函数。如图7-4:</p>

<p><img src="./images/7-4.png" alt="img" title=""></p>

<p>DelegateToFileSystem抽象类:</p>

<p><img src="./images/7-5.png" alt="img" title=""></p>

<h3 id="75-delegatetofilesystem">7.5 DelegateToFileSystem</h3>

<p>顾名思义，DelegateToFileSystem 是一个代理类。 <br>
它简单的将所有的操作交给 FileSystm类型的属性fsImpl 来处理。</p>

<p>目前Hadoop源码中只有FtpFs和RawLocalFs是从其派生的。</p>

<h3 id="76-filecontext类">7.6 FileContext类</h3>

<p>FileContext 类是0.21 版中提供的新的API，它为应用程序编写者提供了访问Hadoop文件系统的接口，例如create open list等方法。</p>

<p>类图如图7-6:</p>

<p><img src="./images/7-6.jpg" alt="img" title=""></p>

<h5 id="761-hadoop中的路径">7.6.1 Hadoop中的路径</h5>

<ul>
<li>Hadoop中使用Path 来表示一个文件路径。Path 中含有文件所在的URI 。</li>
<li>Hadoop支持URI 名字空间和URI 名字。Hadoop中URI 名字非常灵活，使用者可以在不知道</li>
<li>服务器地址或名字的情况下，访问默认的文件系统。默认的文件系统通过配置文件来制定。</li>
</ul>

<p>Hadoop中路径名有三种形式： <br>
1. 完全限定的URI ：scheme://authority/path <br>
2. 以斜杠开头的路径：/path  表示相对于默认的文件系统，即相当于default-scheme:// default-authority/path <br>
3. 相对路径：path  相对于工作目录 <br>
   完全限定的URI 和以斜杠开头的路径称为绝对路径。 <br>
   但如下形式的路径则是非法的：scheme:foo/bar</p>

<p>Hadoop 中文件和目录的路径用 Path 类表示。Path 的表示与 Unix 路径相似,使用’/’来分隔目 <br>
录,而不是’\’。Path类图如图7-7:</p>

<p><img src="./images/7-7.jpg" alt="img" title=""></p>

<h4 id="762-server-side属性">7.6.2 server side属性</h4>

<p>所有的文件系统实例(例如文件系统的部署)都有默认属性。这些属性叫做 server side (SS) <br>
defaults。像 create 这样的操作允许选择多种属性:要么当做参数传给它,要么使用 SS 属性。</p>

<p>SS 属性由 FsServerDefaults 表示, 如图7-8:</p>

<p><img src="./images/7-8.jpg" alt="img" title=""></p>

<p>与文件系统有关的 SS 属性有</p>

<ul>
<li>the home directory (default is “/user/userName”)</li>
<li>the initial wd (only for local fs)</li>
<li>replication factor 分片因子</li>
<li>block size</li>
<li>buffer size</li>
<li>bytesPerChecksum (if used).</li>
</ul>

<h3 id="763-filecontext">7.6.3 FileContext</h3>

<p>FileContext 由默认文件系统、工作目录和umask 定义。</p>

<p>获得一个FileContext 可以使用FileContext 的静态方法： getFileContext();getLocalFSFileContext()</p>

<p>getFileContext  有多重重载的形式。但最终都是调用了如下函数：</p>

<pre class="prettyprint prettyprinted"><code class="language-java"><span class="pln">  </span><span class="com">/**
   * Protected Static Factory methods for getting a FileContexts
   * that take a AbstractFileSystem as input. To be used for testing.
   */</span><span class="pln">

  </span><span class="com">/**
   * Create a FileContext with specified FS as default using the specified
   * config.
   * 
   * @param defFS
   * @param aConf
   * @return new FileContext with specifed FS as default.
   */</span><span class="pln">
  </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">static</span><span class="pln"> </span><span class="typ">FileContext</span><span class="pln"> getFileContext</span><span class="pun">(</span><span class="kwd">final</span><span class="pln"> </span><span class="typ">AbstractFileSystem</span><span class="pln"> defFS</span><span class="pun">,</span><span class="pln">
                    </span><span class="kwd">final</span><span class="pln"> </span><span class="typ">Configuration</span><span class="pln"> aConf</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">FileContext</span><span class="pun">(</span><span class="pln">defFS</span><span class="pun">,</span><span class="pln"> </span><span class="typ">FsPermission</span><span class="pun">.</span><span class="pln">getUMask</span><span class="pun">(</span><span class="pln">aConf</span><span class="pun">),</span><span class="pln"> aConf</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  </span><span class="com">/**
   * Create a FileContext for specified file system using the default config.
   * 
   * @param defaultFS
   * @return a FileContext with the specified AbstractFileSystem
   *                 as the default FS.
   */</span><span class="pln">
  </span><span class="kwd">protected</span><span class="pln"> </span><span class="kwd">static</span><span class="pln"> </span><span class="typ">FileContext</span><span class="pln"> getFileContext</span><span class="pun">(</span><span class="pln">
    </span><span class="kwd">final</span><span class="pln"> </span><span class="typ">AbstractFileSystem</span><span class="pln"> defaultFS</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> getFileContext</span><span class="pun">(</span><span class="pln">defaultFS</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Configuration</span><span class="pun">());</span><span class="pln">
  </span><span class="pun">}</span></code></pre>

<p>public void setWorkingDirectory(final  Path newWDir) throws IOException 用来设置工作目录。</p>

<p>FileContext 中的很多方法是用来取代FileSystem 中的方法的。 <br>
包括create，mkdir，delete，open ，setReplication ，rename ， <br>
setPermission ，setOwner ，setTimes ，getFileStatus， <br>
getFileLinkStatus，getLinkTarget ，getFileBlockLocations等方法在AbstractFileSystem 中都有对应的方法。 <br>
这些方法的实现具有相同的形式。比如open 方法的代码如下：</p>

<pre class="prettyprint prettyprinted"><code class="language-java"><span class="pln">  </span><span class="com">/**
   * Opens an FSDataInputStream at the indicated Path.
   * 
   * @param f the file name to open
   * @param bufferSize the size of the buffer to be used.
   * 
   * @throws AccessControlException If access is denied
   * @throws FileNotFoundException If file &lt;code&gt;f&lt;/code&gt; does not exist
   * @throws UnsupportedFileSystemException If file system for &lt;code&gt;f&lt;/code&gt; is
   *           not supported
   * @throws IOException If an I/O error occurred
   * 
   * Exceptions applicable to file systems accessed over RPC:
   * @throws RpcClientException If an exception occurred in the RPC client
   * @throws RpcServerException If an exception occurred in the RPC server
   * @throws UnexpectedServerException If server implementation throws 
   *           undeclared exception to RPC server
   */</span><span class="pln">
  </span><span class="kwd">public</span><span class="pln"> </span><span class="typ">FSDataInputStream</span><span class="pln"> open</span><span class="pun">(</span><span class="kwd">final</span><span class="pln"> </span><span class="typ">Path</span><span class="pln"> f</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">final</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> bufferSize</span><span class="pun">)</span><span class="pln">
      </span><span class="kwd">throws</span><span class="pln"> </span><span class="typ">AccessControlException</span><span class="pun">,</span><span class="pln"> </span><span class="typ">FileNotFoundException</span><span class="pun">,</span><span class="pln">
      </span><span class="typ">UnsupportedFileSystemException</span><span class="pun">,</span><span class="pln"> </span><span class="typ">IOException</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">final</span><span class="pln"> </span><span class="typ">Path</span><span class="pln"> absF </span><span class="pun">=</span><span class="pln"> fixRelativePart</span><span class="pun">(</span><span class="pln">f</span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">FSLinkResolver</span><span class="pun">&lt;</span><span class="typ">FSDataInputStream</span><span class="pun">&gt;()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="lit">@Override</span><span class="pln">
      </span><span class="kwd">public</span><span class="pln"> </span><span class="typ">FSDataInputStream</span><span class="pln"> next</span><span class="pun">(</span><span class="kwd">final</span><span class="pln"> </span><span class="typ">AbstractFileSystem</span><span class="pln"> fs</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">final</span><span class="pln"> </span><span class="typ">Path</span><span class="pln"> p</span><span class="pun">)</span><span class="pln"> 
        </span><span class="kwd">throws</span><span class="pln"> </span><span class="typ">IOException</span><span class="pun">,</span><span class="pln"> </span><span class="typ">UnresolvedLinkException</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="kwd">return</span><span class="pln"> fs</span><span class="pun">.</span><span class="pln">open</span><span class="pun">(</span><span class="pln">p</span><span class="pun">,</span><span class="pln"> bufferSize</span><span class="pun">);</span><span class="pln">
      </span><span class="pun">}</span><span class="pln">
    </span><span class="pun">}.</span><span class="pln">resolve</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">,</span><span class="pln"> absF</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span></code></pre>

<p>内部FSLinkResolver<t>抽象模板使用来解析路径中的符号链接的。 <br>
public abstract T next(final AbstractFileSystem fs, final Path p)为其抽象方法。 <br>
resolve 方法如下：</t></p>

<pre class="prettyprint prettyprinted"><code class="language-java"><span class="pln">  </span><span class="com">/**
   * Resolves all symbolic links in the specified path.
   * Returns the new path object.
   */</span><span class="pln">
  </span><span class="kwd">protected</span><span class="pln"> </span><span class="typ">Path</span><span class="pln"> resolve</span><span class="pun">(</span><span class="kwd">final</span><span class="pln"> </span><span class="typ">Path</span><span class="pln"> f</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">throws</span><span class="pln"> </span><span class="typ">FileNotFoundException</span><span class="pun">,</span><span class="pln">
      </span><span class="typ">UnresolvedLinkException</span><span class="pun">,</span><span class="pln"> </span><span class="typ">AccessControlException</span><span class="pun">,</span><span class="pln"> </span><span class="typ">IOException</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">FSLinkResolver</span><span class="pun">&lt;</span><span class="typ">Path</span><span class="pun">&gt;()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="lit">@Override</span><span class="pln">
      </span><span class="kwd">public</span><span class="pln"> </span><span class="typ">Path</span><span class="pln"> next</span><span class="pun">(</span><span class="kwd">final</span><span class="pln"> </span><span class="typ">AbstractFileSystem</span><span class="pln"> fs</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">final</span><span class="pln"> </span><span class="typ">Path</span><span class="pln"> p</span><span class="pun">)</span><span class="pln"> 
        </span><span class="kwd">throws</span><span class="pln"> </span><span class="typ">IOException</span><span class="pun">,</span><span class="pln"> </span><span class="typ">UnresolvedLinkException</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="kwd">return</span><span class="pln"> fs</span><span class="pun">.</span><span class="pln">resolvePath</span><span class="pun">(</span><span class="pln">p</span><span class="pun">);</span><span class="pln">
      </span><span class="pun">}</span><span class="pln">
    </span><span class="pun">}.</span><span class="pln">resolve</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">,</span><span class="pln"> f</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span></code></pre>

<p>FileContext 的getFSofPath 方法用来获得支持指定路径path 的文件系统。 <br>
该方法首先检查路径path 是不是属于默认文件系统支持的路径， <br>
如果是则返回 FileContext.defaultFS 属性；否则AbstractFileSystem.get来获取对应的文件系统。</p>

<p>在获得文件系统fs 之后，resolve 会调用next 方法，并返回其结果。 <br>
如果出现异常，则解析路径中的符号链接，再次调用next 。</p>

<p>总的来说，FileContext.open 是通过调用AbstractFileSystem.open来实现的。</p>

<h2 id="8-结论与进一步的工作">8 结论与进一步的工作</h2></div></body>
</html>